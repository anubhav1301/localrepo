<html>
	<head>
		<style>

			body {
				font-family: sans-serif;
			}

			.TestCaseImplTitle {
				color: blue;
				font: 0.85em arial;
				font-weight: bold;
			}

			.TestCaseImpl .TestItemTitle {
				color: blue;
				border-top: 2px solid blue;
				border-bottom: 2px solid blue;
				margin-bottom: 0.5em;
			}

			.TestCaseImpl .TestItemOutcome {
				border-top: 2px solid blue;
				border-bottom: 2px solid blue;
			}

			.ApiCallImpl .TestItemTitle{
				color: blue;
				border-top: 1px solid blue;
				border-bottom: 1px solid blue;
				padding-top: 0.1em;
				padding-bottom: 0.1em;
				margin-top: 0.25em;
				margin-bottom: 0.25em;
			}

			.ApiCallImpl .TestItemOutcome {
				border-top: 1px solid blue;
				border-bottom: 1px solid blue;
				padding-top: 0.1em;
				padding-bottom: 0.1em;
				margin-top: 0.25em;
			}

			.TestItemOutcome {
				padding-left: 20px;
				padding-top: 0.1em;
				padding-bottom: 0.1em;
				clear: both;
			}
			
			.TestItemOutcome.Successful {
				color: green;
				background: url('../../successful_16x16.gif') no-repeat 0 0.15em;
			}

			.TestItemOutcome.Failed {
				color: red;
				background: url('../../failed_16x16.gif') no-repeat 0 0.15em;
				font-weight: bold;
			}

			.TestItemOutcome.Skipped {
				color: orange;
				background: url('../../skipped_16x16.gif') no-repeat 0 0.15em;
			}

			.TestOutput {
				font: 0.9em arial;
				color: black;
				margin-top: 0.15em;
				margin-bottom: 0.15em;
			}

			.TestOutput.err {
				font-weight: bold;
				color: red;
			}

			.TestOutput.war {
				font-weight: bold;
				color: orange;
			}

			.ApiCallImpl{
				margin-left: 1em;
				margin-bottom: 0.4em;
			}

			.TestCaseCallImpl{
				margin-left: 1em;
				margin-bottom: 0.4em;
			}
			
		</style>
	</head>
	<body><div id='detail-body'>
	<div style='float: right;'><img src='../..//provar_logo_400x100.png' height='50'/></div>
<h2><img src='../..//testcase_16x16.png' style='height: 24; padding-top: 4px;'/> UI Fill.testcase</h2>
<div class='TestCaseImpl'><div class='TestItemTitle'><div style='float: right; font-size: 0.8em;'><img src='../..//timer_16x16.gif' style='height: 16; padding-top: 2px;'/><span style='padding-bottom: 2px;'>13:54:54 (00:00.000)</span></div>Start of Test Case UI Fill.testcase</div><div class='ApiCallImpl'><div class='TestItemTitle'><div style='float: right; font-size: 0.8em;'><img src='../..//timer_16x16.gif' style='height: 16; padding-top: 2px;'/><span style='padding-bottom: 2px;'>13:54:54 (00:00.000)</span></div>Start of Test Step Salesforce Connect: SalesforceConn (Test)</div><div class='TestOutput inf'>Connecting to Salesforce as SalesforceConn</div><div class='TestOutput off'>Successfully connected to Salesforce as SalesforceConn</div><div class='TestItemOutcome Successful'><div style='float: right; font-size: 0.8em;'><img src='../..//timer_16x16.gif' style='height: 16; padding-top: 2px;'/><span style='padding-bottom: 2px;'>13:54:55 (00:01.709)</span></div>Test Step successful.</div></div><div class='TestOutput inf'>Loading data from Parameter Value Source ...</div><div class='TestOutput inf'>Loading Parameter Value Source row 1:</div><div class='TestOutput inf'>==Column=&gt; Name = PrimitiveValueImpl [ value: Dhruv , valueId=null, createdUpdateSeq=-1, updatedUpdateSeq=-1]</div><div class='TestOutput inf'>==Column=&gt; Phone = PrimitiveValueImpl [ value: 8798765436, valueId=null, createdUpdateSeq=-1, updatedUpdateSeq=-1]</div><div class='TestOutput inf'>Loading Parameter Value Source row 2:</div><div class='TestOutput inf'>==Column=&gt; Name = PrimitiveValueImpl [ value: Ronit, valueId=null, createdUpdateSeq=-1, updatedUpdateSeq=-1]</div><div class='TestOutput inf'>==Column=&gt; Phone = PrimitiveValueImpl [ value: 6787645637, valueId=null, createdUpdateSeq=-1, updatedUpdateSeq=-1]</div><div class='TestOutput inf'>Loading Parameter Value Source row 3:</div><div class='TestOutput inf'>==Column=&gt; Name = PrimitiveValueImpl [ value: Umesh, valueId=null, createdUpdateSeq=-1, updatedUpdateSeq=-1]</div><div class='TestOutput inf'>==Column=&gt; Phone = PrimitiveValueImpl [ value: 8745678934, valueId=null, createdUpdateSeq=-1, updatedUpdateSeq=-1]</div><div class='TestOutput off'>Loaded 3 rows from Parameter Value Source.</div><div class='TestOutput inf'>Loading data from Parameter Value Source ...</div><div class='TestOutput inf'>Loading Parameter Value Source row 1:</div><div class='TestOutput inf'>==Column=&gt; Name = PrimitiveValueImpl [ value: Dhruv , valueId=null, createdUpdateSeq=-1, updatedUpdateSeq=-1]</div><div class='TestOutput inf'>==Column=&gt; Phone = PrimitiveValueImpl [ value: 8798765436, valueId=null, createdUpdateSeq=-1, updatedUpdateSeq=-1]</div><div class='TestOutput inf'>Loading Parameter Value Source row 2:</div><div class='TestOutput inf'>==Column=&gt; Name = PrimitiveValueImpl [ value: Ronit, valueId=null, createdUpdateSeq=-1, updatedUpdateSeq=-1]</div><div class='TestOutput inf'>==Column=&gt; Phone = PrimitiveValueImpl [ value: 6787645637, valueId=null, createdUpdateSeq=-1, updatedUpdateSeq=-1]</div><div class='TestOutput inf'>Loading Parameter Value Source row 3:</div><div class='TestOutput inf'>==Column=&gt; Name = PrimitiveValueImpl [ value: Umesh, valueId=null, createdUpdateSeq=-1, updatedUpdateSeq=-1]</div><div class='TestOutput inf'>==Column=&gt; Phone = PrimitiveValueImpl [ value: 8745678934, valueId=null, createdUpdateSeq=-1, updatedUpdateSeq=-1]</div><div class='TestOutput off'>Loaded 3 rows from Parameter Value Source.</div><div class='ApiCallImpl'><div class='TestItemTitle'><div style='float: right; font-size: 0.8em;'><img src='../..//timer_16x16.gif' style='height: 16; padding-top: 2px;'/><span style='padding-bottom: 2px;'>13:54:56 (00:01.787)</span></div>Start of Test Step UIFILLFILE </div><div class='TestItemOutcome Successful'><div style='float: right; font-size: 0.8em;'><img src='../..//timer_16x16.gif' style='height: 16; padding-top: 2px;'/><span style='padding-bottom: 2px;'>13:54:56 (00:01.834)</span></div>Test Step successful.</div></div><div class='ApiCallImpl'><div class='TestItemTitle'><div style='float: right; font-size: 0.8em;'><img src='../..//timer_16x16.gif' style='height: 16; padding-top: 2px;'/><span style='padding-bottom: 2px;'>13:54:56 (00:01.838)</span></div>Start of Test Step For Each: {SourceData}=&gt;Row</div><div class='TestOutput inf'>Start of iteration 1 of 3.</div><div class='TestClauseImpl'><div class='TestItemTitle'><div style='float: right; font-size: 0.8em;'><img src='../..//timer_16x16.gif' style='height: 16; padding-top: 2px;'/><span style='padding-bottom: 2px;'>13:54:56 (00:01.838)</span></div>Start of TestClauseImpl Iteration 1</div><div class='ApiCallImpl'><div class='TestItemTitle'><div style='float: right; font-size: 0.8em;'><img src='../..//timer_16x16.gif' style='height: 16; padding-top: 2px;'/><span style='padding-bottom: 2px;'>13:54:56 (00:01.838)</span></div>Start of Test Step On SF Account New screen</div><div class='TestOutput inf'>Start of With Screen.  Connection Name: SalesforceConn, target: sf:ui:target?object=Account&action=New</div><div class='TestOutput inf'>Opening Chrome webdriver instance to https://login.salesforce.com/</div><div class='TestOutput off'>Successfully opened Chrome webdriver to https://login.salesforce.com/</div><div class='TestOutput inf'>Opening Page context.  Name: screen, data: null, frame: null</div><div class='TestOutput inf'>Opening Salesforce page.  Object: Account, RelatedList: null, Action: New, Page URL: /lightning/o/001/list, Current URL: chrome://new-tab-page/</div><div class='TestOutput inf'>Opening Salesforce user home page</div><div class='TestOutput off'>Successfully opened user home page</div><div class='TestOutput inf'>Clicking the New Button</div><div class='TestOutput inf'>Find action link element using xpath: (//*[contains(@class, 'active') and ( (self::div and contains(@class, 'oneContent')) or (self::section and ((contains(@class, 'oneConsoleTab') and ancestor::div[contains(@class, 'active') and (contains(@class, 'oneWorkspace') or contains(@class, 'navexWorkspace')) and not(contains(@class, 'hasPinnedRegionTemplate') and contains(@class, 'hasActiveSubtab'))]) or (contains(@class, 'tabContent') and ancestor::div[contains(@class, 'wsTabset') and not(contains(@class, 'wsTabBarHidden'))] and ancestor::div[contains(@class, 'active') and (contains(@class, 'oneWorkspace') or contains(@class, 'navexWorkspace')) and contains(@class, 'hasPinnedRegionTemplate') and contains(@class, 'hasActiveSubtab')]))) )]//div[contains(@class, 'forceListViewManager')]//ul[contains(@class, 'oneActionsRibbon')] | //div[contains(@class, 'forceActionsDropDownMenuList') and contains(@class, ' visible')])//a[contains(@data-aura-rendered-by, '858:0')]</div><div class='TestOutput inf'>Clicking WebElement.  WebElement [tag: a, text: New, href: javascript:void(0);]</div><div class='TestOutput inf'>Hover&gt;Clicking WebElement.  WebElement [tag: h2, text: New Account]</div><div class='TestOutput inf'>Going to update browser window handles.</div><div class='TestOutput off'>Successfully updated browser window handles.</div><div class='ApiCallImpl'><div class='TestItemTitle'><div style='float: right; font-size: 0.8em;'><img src='../..//timer_16x16.gif' style='height: 16; padding-top: 2px;'/><span style='padding-bottom: 2px;'>13:55:15 (00:21.497)</span></div>Start of Test Step UI Fill</div><div class='TestOutput inf'>Start of UI Fill.  Connection: SalesforceConn</div><div class='TestOutput inf'>Processing Named Value.  Name: Name, Value: PrimitiveValueImpl [ value: Dhruv , valueId=1cc, createdUpdateSeq=157, updatedUpdateSeq=157]</div><div class='TestOutput inf'>Finding field placehoder using xpath: //div[contains(@class, 'open') and (contains(@class, 'forceModal') or contains(@class, 'uiModal')) and (contains(@class, 'active') or following-sibling::div[contains(@class, 'forceFormPageError')])][last()]//*[contains(@class, 'forceDetailPanel') or contains(@class, 'detail-panel-root')]//*[(self::records-record-layout-section) or ((self::section or self::div or self::fieldset) and contains(@class,'forcePageBlockSection '))][1]//*[((self::label and (contains(@class,'uiLabel') or contains(@class,'slds-form-element__label')) and not(contains(@class, 'hide '))) or (self::span and (contains(@class,'inputLabel') or contains(@class,'slds-form-element__label'))) or (self::div and contains(@class,'test-id__field-label-container')) or (self::lightning-grouped-combobox and contains(@class, 'forceTextEnumLookup')) or (self::div and contains(@class, 'lightningInputRichText') or self::lightning-input-rich-text)) and (.//text()[normalize-space()='Account Name'] or .//text() = 'Account Name')]/ancestor::div[1]</div><div class='TestOutput inf'>Find field using relative xpath: .//input</div><div class='TestOutput inf'>Waiting for element to be present.  Timeout(seconds): 10</div><div class='TestOutput inf'>Found element: [[[org.openqa.selenium.remote.RemoteWebElement@7143a486 -&gt; unknown locator]] -&gt; xpath: .//input]</div><div class='TestOutput inf'>Got webElement.  tagName: INPUT, id: input-230, type: text, class: slds-input</div><div class='TestOutput inf'>Typing value.  tagName: INPUT, type: text, value: Dhruv , blur: false</div><div class='TestOutput inf'>Processing Named Value.  Name: Phone, Value: PrimitiveValueImpl [ value: 8798765436, valueId=1ce, createdUpdateSeq=157, updatedUpdateSeq=157]</div><div class='TestOutput inf'>Finding field placehoder using xpath: //div[contains(@class, 'open') and (contains(@class, 'forceModal') or contains(@class, 'uiModal')) and (contains(@class, 'active') or following-sibling::div[contains(@class, 'forceFormPageError')])][last()]//*[contains(@class, 'forceDetailPanel') or contains(@class, 'detail-panel-root')]//*[(self::records-record-layout-section) or ((self::section or self::div or self::fieldset) and contains(@class,'forcePageBlockSection '))][1]//*[((self::label and (contains(@class,'uiLabel') or contains(@class,'slds-form-element__label')) and not(contains(@class, 'hide '))) or (self::span and (contains(@class,'inputLabel') or contains(@class,'slds-form-element__label'))) or (self::div and contains(@class,'test-id__field-label-container')) or (self::lightning-grouped-combobox and contains(@class, 'forceTextEnumLookup')) or (self::div and contains(@class, 'lightningInputRichText') or self::lightning-input-rich-text)) and (.//text()[normalize-space()='Phone'] or .//text() = 'Phone')]/ancestor::div[1]</div><div class='TestOutput inf'>Find field using relative xpath: .//input</div><div class='TestOutput inf'>Waiting for element to be present.  Timeout(seconds): 10</div><div class='TestOutput inf'>Found element: [[[org.openqa.selenium.remote.RemoteWebElement@7143a48a -&gt; unknown locator]] -&gt; xpath: .//input]</div><div class='TestOutput inf'>Got webElement.  tagName: INPUT, id: input-233, type: text, class: slds-input</div><div class='TestOutput inf'>Typing value.  tagName: INPUT, type: text, value: 8798765436, blur: false</div><div class='TestOutput inf'>Going to update browser window handles.</div><div class='TestOutput off'>Successfully updated browser window handles.</div><div class='TestItemOutcome Successful'><div style='float: right; font-size: 0.8em;'><img src='../..//timer_16x16.gif' style='height: 16; padding-top: 2px;'/><span style='padding-bottom: 2px;'>13:55:22 (00:27.804)</span></div>Test Step successful.</div></div><div class='ApiCallImpl'><div class='TestItemTitle'><div style='float: right; font-size: 0.8em;'><img src='../..//timer_16x16.gif' style='height: 16; padding-top: 2px;'/><span style='padding-bottom: 2px;'>13:55:22 (00:27.804)</span></div>Start of Test Step Click the Save button</div><div class='TestOutput inf'>Start of Interact.  Connection: SalesforceConn, Locator: ui:locator?name=save&binding=sf%3Aui%3Abinding%3Aobject%3Fobject%3DAccount%26action%3Dsave, before wait: default, after wait: default, auto retry: ui:wait:autoRetry:timeout=10</div><div class='TestOutput inf'>Locator: ui:locator?name=save&binding=sf%3Aui%3Abinding%3Aobject%3Fobject%3DAccount%26action%3Dsave</div><div class='TestOutput inf'>Interaction: ui:interaction?name=action</div><div class='TestOutput inf'>Switched focus to main window.  URL: https://testing250-dev-ed.develop.lightning.force.com/lightning/o/Account/new?count=1&nooverride=1&useRecordTypeCheck=1&navigationLocation=LIST_VIEW&uid=173217751304232858&backgroundContext=%2Flightning%2Fo%2FAccount%2Flist%3FfilterName%3D__Recent</div><div class='TestOutput inf'>Interaction: ui:interaction?name=action</div><div class='TestOutput inf'>Find action link element using xpath: //div[contains(@class, 'open') and (contains(@class, 'forceModal') or contains(@class, 'uiModal')) and (contains(@class, 'active') or following-sibling::div[contains(@class, 'forceFormPageError')])][last()]//div[(contains(@class, 'footer') and contains(@class, 'active')) or contains(@class, 'footer-visible')]/ancestor::*[self::force-form-footer or (self::records-base-record-form/parent::records-lwc-detail-panel)]//runtime_platform_actions-action-renderer[@apiname='save' or @apiname='SaveEdit']//*[self::a or self::button]</div><div class='TestOutput inf'>Waiting for element to be present.  Timeout(seconds): 10</div><div class='TestOutput inf'>Doing before wait.  waitUrl: default</div><div class='TestOutput inf'>End of &lt;default&gt; wait.</div><div class='TestOutput inf'>Found element: [[ChromeDriver$$EnhancerByCGLIB$$dace278c: chrome on windows (e45746e46e8aba380b784ae57d63e0ca)] -&gt; xpath: //div[contains(@class, 'open') and (contains(@class, 'forceModal') or contains(@class, 'uiModal')) and (contains(@class, 'active') or following-sibling::div[contains(@class, 'forceFormPageError')])][last()]//div[(contains(@class, 'footer') and contains(@class, 'active')) or contains(@class, 'footer-visible')]/ancestor::*[self::force-form-footer or (self::records-base-record-form/parent::records-lwc-detail-panel)]//runtime_platform_actions-action-renderer[@apiname='save' or @apiname='SaveEdit']//*[self::a or self::button]]</div><div class='TestOutput inf'>Clicking WebElement using Javascript Click.  WebElement: WebElement [tag: button, text: Save]</div><div class='TestOutput inf'>Doing after wait.  waitUrl: default</div><div class='TestOutput inf'>End of &lt;default&gt; wait.</div><div class='TestOutput inf'>Going to update browser window handles.</div><div class='TestOutput off'>Successfully updated browser window handles.</div><div class='TestItemOutcome Successful'><div style='float: right; font-size: 0.8em;'><img src='../..//timer_16x16.gif' style='height: 16; padding-top: 2px;'/><span style='padding-bottom: 2px;'>13:55:26 (00:32.186)</span></div>Test Step successful.</div></div><div class='ApiCallImpl'><div class='TestItemTitle'><div style='float: right; font-size: 0.8em;'><img src='../..//timer_16x16.gif' style='height: 16; padding-top: 2px;'/><span style='padding-bottom: 2px;'>13:55:26 (00:32.186)</span></div>Start of Test Step Navigate: Refresh</div><div style='float: right;' ><a target='_blank' href='../../Artifacts/ScreenShot8'><img style='width: 150px; border: solid 2px grey;' src='../../Artifacts/ScreenShot8'></img></a></div><div style='float: right;' ><a target='_blank' href='../../Artifacts/ScreenShot7'><img style='width: 150px; border: solid 2px grey;' src='../../Artifacts/ScreenShot7'></img></a></div><div class='TestOutput inf'>Start of UI Navigate.  Connection: SalesforceConn</div><div class='TestOutput inf'>Sending screenshot.  Data length: 83377</div><div class='TestOutput inf'>Refreshing the current page</div><div class='TestOutput inf'>Sending screenshot.  Data length: 361758</div><div class='TestOutput inf'>Going to update browser window handles.</div><div class='TestOutput off'>Successfully updated browser window handles.</div><div class='TestItemOutcome Successful'><div style='float: right; font-size: 0.8em;'><img src='../..//timer_16x16.gif' style='height: 16; padding-top: 2px;'/><span style='padding-bottom: 2px;'>13:55:35 (00:40.839)</span></div>Test Step successful.</div></div><div class='TestOutput inf'>All Sub-Test Steps were successful.</div><div class='TestOutput inf'>Switched focus to main window.  URL: https://testing250-dev-ed.develop.lightning.force.com/lightning/r/Account/001J200000B7rtgIAB/view</div><div class='TestOutput inf'>Injecting script to get created object ID from aura component</div><div class='TestOutput war'>Some toast message(s) are still open and might cause inconsistent issues in execution.</div><div class='TestOutput inf'>Fetching created Id from URL</div><div class='TestOutput sum'>Storing created Salesforce Object ID.  Result Name: accountId, created ID: &amp;a href='sf:object?connection=SalesforceConn&object=Account&id=001J200000B7rtgIAB'&gt;001J200000B7rtgIAB&amp;/a&gt;, location: https://testing250-dev-ed.develop.lightning.force.com/lightning/r/Account/001J200000B7rtgIAB/view</div><div class='TestOutput inf'>Logging Salesforce Object Id for clean up.  Object Name: Account, id: 001J200000B7rtgIAB</div><div class='TestOutput inf'>Closing Page context.  Name: screen, data: null, frame: null</div><div class='TestOutput inf'>Main window reselected.  Window: main</div><div class='TestOutput inf'>Switched focus to main window.  URL: https://testing250-dev-ed.develop.lightning.force.com/lightning/r/Account/001J200000B7rtgIAB/view</div><div class='TestOutput inf'>Going to update browser window handles.</div><div class='TestOutput off'>Successfully updated browser window handles.</div><div class='TestItemOutcome Successful'><div style='float: right; font-size: 0.8em;'><img src='../..//timer_16x16.gif' style='height: 16; padding-top: 2px;'/><span style='padding-bottom: 2px;'>13:55:44 (00:50.482)</span></div>Test Step successful.</div></div><div class='TestItemOutcome Successful'><div style='float: right; font-size: 0.8em;'><img src='../..//timer_16x16.gif' style='height: 16; padding-top: 2px;'/><span style='padding-bottom: 2px;'>13:55:44 (00:50.482)</span></div>TestClauseImpl successful.</div></div><div class='TestOutput inf'>Start of iteration 2 of 3.</div><div class='TestClauseImpl'><div class='TestItemTitle'><div style='float: right; font-size: 0.8em;'><img src='../..//timer_16x16.gif' style='height: 16; padding-top: 2px;'/><span style='padding-bottom: 2px;'>13:55:44 (00:50.490)</span></div>Start of TestClauseImpl Iteration 2</div><div class='ApiCallImpl'><div class='TestItemTitle'><div style='float: right; font-size: 0.8em;'><img src='../..//timer_16x16.gif' style='height: 16; padding-top: 2px;'/><span style='padding-bottom: 2px;'>13:55:44 (00:50.490)</span></div>Start of Test Step On SF Account New screen</div><div class='TestOutput inf'>Start of With Screen.  Connection Name: SalesforceConn, target: sf:ui:target?object=Account&action=New</div><div class='TestOutput inf'>Opening Page context.  Name: screen, data: null, frame: null</div><div class='TestOutput inf'>Opening Salesforce page.  Object: Account, RelatedList: null, Action: New, Page URL: /lightning/o/001/list, Current URL: https://testing250-dev-ed.develop.lightning.force.com/lightning/r/Account/001J200000B7rtgIAB/view</div><div class='TestOutput inf'>Opening Salesforce user home page</div><div class='TestOutput off'>Successfully opened user home page</div><div class='TestOutput inf'>Clicking the New Button</div><div class='TestOutput inf'>Find action link element using xpath: (//*[contains(@class, 'active') and ( (self::div and contains(@class, 'oneContent')) or (self::section and ((contains(@class, 'oneConsoleTab') and ancestor::div[contains(@class, 'active') and (contains(@class, 'oneWorkspace') or contains(@class, 'navexWorkspace')) and not(contains(@class, 'hasPinnedRegionTemplate') and contains(@class, 'hasActiveSubtab'))]) or (contains(@class, 'tabContent') and ancestor::div[contains(@class, 'wsTabset') and not(contains(@class, 'wsTabBarHidden'))] and ancestor::div[contains(@class, 'active') and (contains(@class, 'oneWorkspace') or contains(@class, 'navexWorkspace')) and contains(@class, 'hasPinnedRegionTemplate') and contains(@class, 'hasActiveSubtab')]))) )]//div[contains(@class, 'forceListViewManager')]//ul[contains(@class, 'oneActionsRibbon')] | //div[contains(@class, 'forceActionsDropDownMenuList') and contains(@class, ' visible')])//a[contains(@data-aura-rendered-by, '1109:0')]</div><div class='TestOutput inf'>Clicking WebElement.  WebElement [tag: a, text: New, href: javascript:void(0);]</div><div class='TestOutput inf'>Hover&gt;Clicking WebElement.  WebElement [tag: h2, text: New Account]</div><div class='TestOutput inf'>Going to update browser window handles.</div><div class='TestOutput off'>Successfully updated browser window handles.</div><div class='ApiCallImpl'><div class='TestItemTitle'><div style='float: right; font-size: 0.8em;'><img src='../..//timer_16x16.gif' style='height: 16; padding-top: 2px;'/><span style='padding-bottom: 2px;'>13:55:57 (01:02.848)</span></div>Start of Test Step UI Fill</div><div class='TestOutput inf'>Start of UI Fill.  Connection: SalesforceConn</div><div class='TestOutput inf'>Processing Named Value.  Name: Name, Value: PrimitiveValueImpl [ value: Ronit, valueId=1d1, createdUpdateSeq=157, updatedUpdateSeq=157]</div><div class='TestOutput inf'>Finding field placehoder using xpath: //*[contains(@class, 'active') and ( (contains(@class, 'open') and (contains(@class, 'forceModal') or contains(@class, 'uiModal'))) or (self::section and ((contains(@class, 'oneConsoleTab') and ancestor::div[contains(@class, 'active') and (contains(@class, 'oneWorkspace') or contains(@class, 'navexWorkspace')) and not(contains(@class, 'hasPinnedRegionTemplate') and contains(@class, 'hasActiveSubtab'))]) or (contains(@class, 'tabContent') and ancestor::div[contains(@class, 'wsTabset') and not(contains(@class, 'wsTabBarHidden'))] and ancestor::div[contains(@class, 'active') and (contains(@class, 'oneWorkspace') or contains(@class, 'navexWorkspace')) and contains(@class, 'hasPinnedRegionTemplate') and contains(@class, 'hasActiveSubtab')]))) )]//*[contains(@class, 'forceDetailPanel') or contains(@class, 'detail-panel-root')]//*[(self::records-record-layout-section) or ((self::section or self::div or self::fieldset) and contains(@class,'forcePageBlockSection '))][1]//*[((self::label and (contains(@class,'uiLabel') or contains(@class,'slds-form-element__label')) and not(contains(@class, 'hide '))) or (self::span and (contains(@class,'inputLabel') or contains(@class,'slds-form-element__label'))) or (self::div and contains(@class,'test-id__field-label-container')) or (self::lightning-grouped-combobox and contains(@class, 'forceTextEnumLookup')) or (self::div and contains(@class, 'lightningInputRichText') or self::lightning-input-rich-text)) and (.//text()[normalize-space()='Account Name'] or .//text() = 'Account Name')]/ancestor::div[1]</div><div class='TestOutput sev'>Error filling field.  Field: Name, cause: [NoSuchWindowException: no such window: target window already closed&amp;br/&gt;from unknown error: web view not found&amp;br/&gt;  (Session info: chrome=130.0.6723.117)&amp;br/&gt;Build info: version: '4.16.1', revision: '9b4c83354e'&amp;br/&gt;System info: os.name: 'Windows 11', os.arch: 'amd64', os.version: '10.0', java.version: '11.0.24'&amp;br/&gt;Driver info: org.openqa.selenium.chrome.ChromeDriver$$EnhancerByCGLIB$$dace278c&amp;br/&gt;Command: [e45746e46e8aba380b784ae57d63e0ca, executeScript {script={ const types =&amp;br/&gt;{&amp;br/&gt;	ANY: 0&amp;br/&gt;	, STRING: 1&amp;br/&gt;	, BOOLEAN: 2&amp;br/&gt;	, SEQUENCE: 3&amp;br/&gt;};&amp;br/&gt;const opTranslations =&amp;br/&gt;{&amp;br/&gt;	"=": "equals"&amp;br/&gt;	, "!=": "not_equals"&amp;br/&gt;	, "(": "paren"&amp;br/&gt;	, "|": "union"&amp;br/&gt;	, "&gt;": "greater_than"&amp;br/&gt;	, "&gt;=": "greater_than_equals"&amp;br/&gt;	, "&amp;": "less_than"&amp;br/&gt;	, "&amp;=": "less_than_equals"&amp;br/&gt;	, "+": "numeric_operation_add"&amp;br/&gt;	, "-": "numeric_operation_subtract"&amp;br/&gt;	, "*": "numeric_operation_multiply"&amp;br/&gt;	, "mod": "numeric_operation_mod"&amp;br/&gt;	, " div ": "numeric_operation_divide"&amp;br/&gt;};&amp;br/&gt;&amp;br/&gt;const nodeNames = {&amp;br/&gt;	SLOT: 'slot',&amp;br/&gt;	DOCUMENT_FRAGMENT: '#document-fragment',&amp;br/&gt;	DOCUMENT: '#document',&amp;br/&gt;	HTML: 'HTML',&amp;br/&gt;	SHADOW_ROOT: '#shadow-root',&amp;br/&gt;}&amp;br/&gt;&amp;br/&gt;const skipAttributeKeys = {&amp;br/&gt;	"responseObjectMetadata": true,&amp;br/&gt;	"choiceTemplateGroupObject": true&amp;br/&gt;};&amp;br/&gt;&amp;br/&gt;class Prop {&amp;br/&gt;&amp;br/&gt;	constructor(localName, value) {&amp;br/&gt;		this.localName = localName;&amp;br/&gt;		this.value = value;&amp;br/&gt;	}&amp;br/&gt;}&amp;br/&gt;&amp;br/&gt;class Context {&amp;br/&gt;&amp;br/&gt;	constructor(node) {&amp;br/&gt;		this.currentPosition = -1;&amp;br/&gt;		this.nodeSet = [];&amp;br/&gt;		if (node) {&amp;br/&gt;			this.addNode(node);&amp;br/&gt;		}&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	isNodeExists(node) {&amp;br/&gt;		return this.nodeSet.some(e =&gt; e === node);&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	addNode(node) {&amp;br/&gt;		this.nodeSet.push(node);&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	firstNode() {&amp;br/&gt;		return this.nodeSet[0];&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	currentNode() {&amp;br/&gt;		return this.currentPosition &gt;= 0 && this.currentPosition &amp; this.nodeSet.length&amp;br/&gt;			? this.nodeSet[this.currentPosition]&amp;br/&gt;			: null;&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	nextNode() {&amp;br/&gt;		this.currentPosition++;&amp;br/&gt;		return this.currentNode();&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;}&amp;br/&gt;&amp;br/&gt;class XpathAstExecutor {&amp;br/&gt;&amp;br/&gt;	constructor() {&amp;br/&gt;		this.baseContextNode = null;&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	// MAIN&amp;br/&gt;&amp;br/&gt;	evaluate(ctxNode, ast) {&amp;br/&gt;&amp;br/&gt;		// Wrap the ast in a NodeSet if it is an array of steps.&amp;br/&gt;		if (ast instanceof Array) {&amp;br/&gt;			ast = { type: 'NodeSet', nodes: ast };&amp;br/&gt;		}&amp;br/&gt;&amp;br/&gt;		this.baseContextNode = ctxNode;&amp;br/&gt;		let ctx = new Context(ctxNode);&amp;br/&gt;		ctx = this.executeInternal(ctx, ast);&amp;br/&gt;		return ctx.nodeSet ? ctx.nodeSet : (ctx instanceof Array ? ctx : [ctx]);&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	executeInternal(ctx, ast) {&amp;br/&gt;&amp;br/&gt;		switch (ast.type) {&amp;br/&gt;			case "Node":&amp;br/&gt;				return this.Node(ctx, ast);&amp;br/&gt;			case "NodeSet":&amp;br/&gt;				return this.NodeSet(ctx, ast);&amp;br/&gt;			case "Literal":&amp;br/&gt;				return this.Literal(ctx, ast);&amp;br/&gt;			case "UnaryOpExpression":&amp;br/&gt;			case "OpExpression":&amp;br/&gt;				let opImplName = "op_" + (opTranslations[ast.operator] || ast.operator);&amp;br/&gt;				let opImpl = Reflect.get(this, opImplName);&amp;br/&gt;				if (!opImpl) {&amp;br/&gt;					throw "No implementation found for operator '" + ast.operator + "'"&amp;br/&gt;					+ "  Expected method name: " + opImplName;&amp;br/&gt;				}&amp;br/&gt;				return opImpl.call(this, ctx, ast);&amp;br/&gt;			case "FunctionCall":&amp;br/&gt;				let fnImplName = "fn_" + ast.function.replace('-', '_');&amp;br/&gt;				let fnImpl = Reflect.get(this, fnImplName);&amp;br/&gt;				if (!fnImpl) {&amp;br/&gt;					throw "No implementation found for function '" + ast.function + "'"&amp;br/&gt;					+ "  Expected method name: " + fnImplName;&amp;br/&gt;				}&amp;br/&gt;				return fnImpl.call(this, ctx, ast);&amp;br/&gt;			default:&amp;br/&gt;				throw "Unsupported language construct '" + ast.type + "'."&amp;br/&gt;				+ "  AST: " + JSON.stringify(ast);&amp;br/&gt;		}&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;&amp;br/&gt;	// NODE & PATH&amp;br/&gt;&amp;br/&gt;	NodeSet(ctx, ast, forceRelative) {&amp;br/&gt;&amp;br/&gt;		let nodes = ast.nodes.slice(0);&amp;br/&gt;&amp;br/&gt;		// If the first AST is a "/' or "//' then make the&amp;br/&gt;		// document the context node.&amp;br/&gt;		if (!forceRelative && nodes.length &gt; 0) {&amp;br/&gt;			let firstAstNode = nodes[0];&amp;br/&gt;			let firstCtxNode = ctx.firstNode();&amp;br/&gt;			if ((firstAstNode.type === 'ShallowPath' || firstAstNode.type === 'DeepPath') && (isElement(firstCtxNode) || firstCtxNode.nodeName === nodeNames.DOCUMENT)) {&amp;br/&gt;				ctx = new Context(this.baseContextNode);&amp;br/&gt;			}&amp;br/&gt;		}&amp;br/&gt;&amp;br/&gt;		let sortNext = false;&amp;br/&gt;		for (var n = 0, nLen = nodes.length; n &amp; nLen; n++) {&amp;br/&gt;			let astNode = nodes[n];&amp;br/&gt;			if (astNode.type === 'ShallowPath') {&amp;br/&gt;				// This is the default 'child' axis.&amp;br/&gt;			}&amp;br/&gt;			else if (astNode.type === 'DeepPath') {&amp;br/&gt;				// According to the spec:&amp;br/&gt;				// - "// is short for /descendant-or-self::node()/"	&amp;br/&gt;				// - see https://www.w3.org/TR/1999/REC-xpath-19991116/#path-abbrev&amp;br/&gt;&amp;br/&gt;				let canUseTagNameTuple = this.useTagNameInDescendantSearch(ctx, nodes, n);&amp;br/&gt;				if (canUseTagNameTuple[0]) {&amp;br/&gt;					ctx = canUseTagNameTuple[1];&amp;br/&gt;				} else {&amp;br/&gt;					let dosAst =&amp;br/&gt;					{&amp;br/&gt;						type: "Node"&amp;br/&gt;						, axis: "descendant-or-self"&amp;br/&gt;						, name: "*"&amp;br/&gt;					};&amp;br/&gt;					ctx = this.executeInternal(ctx, dosAst);&amp;br/&gt;				}&amp;br/&gt;&amp;br/&gt;				// We need to sort the outcome of the next step:&amp;br/&gt;				// - or else the children are presented in the wrong order&amp;br/&gt;				// - see failing tests when the next line is commented out&amp;br/&gt;				// - not sure why&amp;br/&gt;				sortNext = true;&amp;br/&gt;			}&amp;br/&gt;			else if (astNode.type === 'NodeSet') {&amp;br/&gt;				ctx = this.NodeSet(ctx, astNode, true);&amp;br/&gt;			}&amp;br/&gt;			else if (astNode.type === 'Node') {&amp;br/&gt;				ctx = this.Node(ctx, astNode);&amp;br/&gt;				if (!astNode.fn && sortNext) {&amp;br/&gt;					sort(ctx);&amp;br/&gt;					sortNext = false;&amp;br/&gt;				}&amp;br/&gt;			}&amp;br/&gt;			else {&amp;br/&gt;				// Typically a Union or Grouping.&amp;br/&gt;				ctx = this.executeInternal(ctx, astNode);&amp;br/&gt;			}&amp;br/&gt;		}&amp;br/&gt;&amp;br/&gt;		return ctx;&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	Node(ctx, ast) {&amp;br/&gt;&amp;br/&gt;		let _this = this;&amp;br/&gt;		let resultCtx = new Context();&amp;br/&gt;		if (ast.fn) {&amp;br/&gt;			if (ctx.currentNode()) {&amp;br/&gt;				processFnNode(resultCtx, ctx.currentNode());&amp;br/&gt;			}&amp;br/&gt;			else {&amp;br/&gt;				while (ctx.nextNode()) {&amp;br/&gt;					processFnNode(resultCtx, ctx.currentNode());&amp;br/&gt;				}&amp;br/&gt;			}&amp;br/&gt;			return resultCtx;&amp;br/&gt;		} else {&amp;br/&gt;			// Processing for @ abbreviation.  From the spec:&amp;br/&gt;			// - "There is also an abbreviation for attributes: attribute:: can be abbreviated to @.&amp;br/&gt;			//    For example, a location path para[@type="warning"] is short for child::para[attribute::type="warning"]&amp;br/&gt;			//    and so selects para children with a type attribute with value equal to warning."&amp;br/&gt;			// - see https://www.w3.org/TR/1999/REC-xpath-19991116/#path-abbrev&amp;br/&gt;			if (ast.name.substring(0, 1) === '@') {&amp;br/&gt;				ast.axis = 'attribute';&amp;br/&gt;				ast.name = ast.name.substring(1);&amp;br/&gt;			}&amp;br/&gt;&amp;br/&gt;			if (ast.name === '.') {&amp;br/&gt;				ast.axis = 'self';&amp;br/&gt;				ast.name = '*';&amp;br/&gt;			}&amp;br/&gt;&amp;br/&gt;			if (ast.name === '..') {&amp;br/&gt;				ast.axis = 'parent';&amp;br/&gt;				ast.name = '*';&amp;br/&gt;			}&amp;br/&gt;&amp;br/&gt;			// Get the iterator for the axis.&amp;br/&gt;			let axisImplName = ast.axis ? 'axis_' + ast.axis : 'axis_child';&amp;br/&gt;			axisImplName = axisImplName.replace('-', '_').replace('-', '_');&amp;br/&gt;			let axisImpl = Reflect.get(this, axisImplName);&amp;br/&gt;&amp;br/&gt;			if (ctx.currentNode()) {&amp;br/&gt;				// A parent process is busy looping through the Nodes:&amp;br/&gt;				// - just process the current node&amp;br/&gt;				processNode(resultCtx, ctx.currentNode(), axisImpl);&amp;br/&gt;			}&amp;br/&gt;			else {&amp;br/&gt;				// Process each node in turn.&amp;br/&gt;				while (ctx.nextNode()) {&amp;br/&gt;					processNode(resultCtx, ctx.currentNode(), axisImpl);&amp;br/&gt;				}&amp;br/&gt;			}&amp;br/&gt;&amp;br/&gt;			return resultCtx;&amp;br/&gt;		}&amp;br/&gt;&amp;br/&gt;		function processFnNode(resultCtx, ctxNode) {&amp;br/&gt;			let valueCtx = new Context();&amp;br/&gt;			const result = _this.executeInternal(new Context(ctxNode), ast.fn);&amp;br/&gt;			if (result instanceof Array) {&amp;br/&gt;				valueCtx.nodeSet = result;&amp;br/&gt;			} else {&amp;br/&gt;				valueCtx.addNode(result);&amp;br/&gt;			}&amp;br/&gt;			// Apply each filter to the nodes in turn&amp;br/&gt;			let filteredCtx = _this.applyFilters(ast, valueCtx);&amp;br/&gt;			filteredCtx.nodeSet.forEach(filteredNode =&gt; {&amp;br/&gt;				if (!resultCtx.isNodeExists(filteredNode)) {&amp;br/&gt;					resultCtx.addNode(filteredNode);&amp;br/&gt;				}&amp;br/&gt;			});&amp;br/&gt;		}&amp;br/&gt;&amp;br/&gt;		function processNode(resultCtx, ctxNode, axisImpl) {&amp;br/&gt;			let axisIt = axisImpl.call(_this, ctxNode);&amp;br/&gt;&amp;br/&gt;			// First load the nodes that match the specified node name and namespace.&amp;br/&gt;			let nameMatchCtx = new Context();&amp;br/&gt;			let node = axisIt();&amp;br/&gt;			while (node) {&amp;br/&gt;				if (testName(node)) {&amp;br/&gt;					nameMatchCtx.addNode(node);&amp;br/&gt;				}&amp;br/&gt;				node = axisIt();&amp;br/&gt;			}&amp;br/&gt;&amp;br/&gt;			// Apply each filter to the nodes in turn&amp;br/&gt;			let filteredCtx = _this.applyFilters(ast, nameMatchCtx);&amp;br/&gt;			filteredCtx.nodeSet.forEach(filteredNode =&gt; {&amp;br/&gt;				if (!resultCtx.isNodeExists(filteredNode)) {&amp;br/&gt;					resultCtx.addNode(filteredNode);&amp;br/&gt;				}&amp;br/&gt;			});&amp;br/&gt;		}&amp;br/&gt;&amp;br/&gt;		function testName(node) {&amp;br/&gt;&amp;br/&gt;			if (isAttr(node) || isProp(node)) {&amp;br/&gt;				if (ast.axis !== 'attribute') {&amp;br/&gt;					return false;&amp;br/&gt;				}&amp;br/&gt;				return ast.name === '*'&amp;br/&gt;					|| ast.name === node.localName;&amp;br/&gt;			}&amp;br/&gt;&amp;br/&gt;			// Element processing.&amp;br/&gt;			if (isElement(node)) {&amp;br/&gt;				return ast.name === '*' || ast.name === node.localName;&amp;br/&gt;			}&amp;br/&gt;&amp;br/&gt;			if (isShadowRoot(node)) {&amp;br/&gt;				return ast.name === '*' || ast.name === nodeNames.SHADOW_ROOT;&amp;br/&gt;			}&amp;br/&gt;&amp;br/&gt;			// Unsupported.&amp;br/&gt;			return false;&amp;br/&gt;		}&amp;br/&gt;&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	useTagNameInDescendantSearch(ctx, nodes, n) {&amp;br/&gt;		let isElementTagName = (nodes[n + 1].type === 'Node' && nodes[n + 1].name && !nodes[n + 1].name.startsWith('@') && !nodes[n + 1].axis);&amp;br/&gt;		let notSameAsPrevNode = (n === 0 || nodes[n + 1].name !== nodes[n - 1].name);&amp;br/&gt;		if (isElementTagName && notSameAsPrevNode) {&amp;br/&gt;			let dosAst =&amp;br/&gt;			{&amp;br/&gt;				type: "Node"&amp;br/&gt;				, axis: "descendant-or-self"&amp;br/&gt;				, name: nodes[n + 1].name&amp;br/&gt;			};&amp;br/&gt;&amp;br/&gt;			let parentNodes = new Set(ctx.nodeSet);&amp;br/&gt;			ctx = this.executeInternal(ctx, dosAst);&amp;br/&gt;			let nodeSet = new Set(ctx.nodeSet);&amp;br/&gt;			Array.from(parentNodes.values()).forEach(e =&gt; nodeSet.delete(e));&amp;br/&gt;			ctx.nodeSet = Array.from(new Set(Array.from(nodeSet).map(e =&gt; getParentNode(e))));&amp;br/&gt;			return [true, ctx];&amp;br/&gt;		}&amp;br/&gt;		return [false, ctx];&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	Literal(ctx, ast) {&amp;br/&gt;&amp;br/&gt;		let value = ast.value;&amp;br/&gt;&amp;br/&gt;		// Remove the quotes from string values.&amp;br/&gt;		if (value.length &gt; 1 && value.substring(0, 1) === "'" && value.substring(value.length - 1) === "'") {&amp;br/&gt;			value = value.substring(1, value.length - 1);&amp;br/&gt;		}&amp;br/&gt;		else if (value.length &gt; 1 && value.substring(0, 1) === '"' && value.substring(value.length - 1) === '"') {&amp;br/&gt;			value = value.substring(1, value.length - 1);&amp;br/&gt;		}&amp;br/&gt;&amp;br/&gt;		return value;&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;&amp;br/&gt;	// OPERATORS&amp;br/&gt;&amp;br/&gt;	op_equals(ctx, ast) {&amp;br/&gt;		return this.comparisonOp(ctx, ast, function (leftValue, rightValue) {&amp;br/&gt;			return resolveValue(leftValue, types.STRING) == rightValue;&amp;br/&gt;		});&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	op_not_equals(ctx, ast) {&amp;br/&gt;		return this.comparisonOp(ctx, ast, function (leftValue, rightValue) {&amp;br/&gt;			return resolveValue(leftValue, types.STRING) != rightValue;&amp;br/&gt;		});&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	op_greater_than(ctx, ast) {&amp;br/&gt;		return this.comparisonOp(ctx, ast, function (leftValue, rightValue) {&amp;br/&gt;			leftValue = resolveValue(leftValue, types.STRING);&amp;br/&gt;			leftValue = typeof (leftValue) === 'string' ? parseInt(leftValue, 10) : leftValue;&amp;br/&gt;&amp;br/&gt;			rightValue = resolveValue(rightValue, types.STRING);&amp;br/&gt;			rightValue = typeof (rightValue) === 'string' ? parseInt(rightValue, 10) : rightValue;&amp;br/&gt;&amp;br/&gt;			return leftValue &gt; rightValue;&amp;br/&gt;		});&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	op_less_than(ctx, ast) {&amp;br/&gt;		return this.comparisonOp(ctx, ast, function (leftValue, rightValue) {&amp;br/&gt;			leftValue = resolveValue(leftValue, types.STRING);&amp;br/&gt;			leftValue = typeof (leftValue) === 'string' ? parseInt(leftValue, 10) : leftValue;&amp;br/&gt;&amp;br/&gt;			rightValue = resolveValue(rightValue, types.STRING);&amp;br/&gt;			rightValue = typeof (rightValue) === 'string' ? parseInt(rightValue, 10) : rightValue;&amp;br/&gt;&amp;br/&gt;			return leftValue &amp; rightValue;&amp;br/&gt;		});&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	op_greater_than_equals(ctx, ast) {&amp;br/&gt;		return this.comparisonOp(ctx, ast, function (leftValue, rightValue) {&amp;br/&gt;			leftValue = resolveValue(leftValue, types.STRING);&amp;br/&gt;			leftValue = typeof (leftValue) === 'string' ? parseInt(leftValue, 10) : leftValue;&amp;br/&gt;&amp;br/&gt;			rightValue = resolveValue(rightValue, types.STRING);&amp;br/&gt;			rightValue = typeof (rightValue) === 'string' ? parseInt(rightValue, 10) : rightValue;&amp;br/&gt;&amp;br/&gt;			return leftValue &gt;= rightValue;&amp;br/&gt;		});&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	op_less_than_equals(ctx, ast) {&amp;br/&gt;		return this.comparisonOp(ctx, ast, function (leftValue, rightValue) {&amp;br/&gt;			leftValue = resolveValue(leftValue, types.STRING);&amp;br/&gt;			leftValue = typeof (leftValue) === 'string' ? parseInt(leftValue, 10) : leftValue;&amp;br/&gt;&amp;br/&gt;			rightValue = resolveValue(rightValue, types.STRING);&amp;br/&gt;			rightValue = typeof (rightValue) === 'string' ? parseInt(rightValue, 10) : rightValue;&amp;br/&gt;&amp;br/&gt;			return leftValue &amp;= rightValue;&amp;br/&gt;		});&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	op_and(ctx, ast) {&amp;br/&gt;		for (var i = 0; i &amp; ast.exprs.length; i++) {&amp;br/&gt;			if (!this.expressionOp(ctx, ast.exprs[i])) {&amp;br/&gt;				return false;&amp;br/&gt;			}&amp;br/&gt;		}&amp;br/&gt;		return true;&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	op_or(ctx, ast) {&amp;br/&gt;		for (var i = 0; i &amp; ast.exprs.length; i++) {&amp;br/&gt;			if (this.expressionOp(ctx, ast.exprs[i])) {&amp;br/&gt;				return true;&amp;br/&gt;			}&amp;br/&gt;		}&amp;br/&gt;		return false;&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	op_paren(ctx, ast) {&amp;br/&gt;		let resultCtx = new Context();&amp;br/&gt;		// Resolve the left and right values.&amp;br/&gt;		let value = this.executeInternal(ctx, ast.expr);&amp;br/&gt;		if (ast.filters) {&amp;br/&gt;			// Apply each filter to the nodes in turn&amp;br/&gt;			let filteredCtx = this.applyFilters(ast, value);&amp;br/&gt;			filteredCtx.nodeSet.forEach(filteredNode =&gt; { resultCtx.addNode(filteredNode) });&amp;br/&gt;			return resultCtx;&amp;br/&gt;		}&amp;br/&gt;		return value;&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	op_union(ctx, ast) {&amp;br/&gt;		const values = [];&amp;br/&gt;		ast.exprs.forEach(expr =&gt; {&amp;br/&gt;			values.push(toArray(this.executeInternal(ctx, expr)));&amp;br/&gt;		});&amp;br/&gt;		let resultCtx = new Context();&amp;br/&gt;		resultCtx.nodeSet = values[0];&amp;br/&gt;&amp;br/&gt;		for (var i = 1; i &amp; values.length; i++) {&amp;br/&gt;			values[i].forEach(val =&gt; {&amp;br/&gt;				if (resultCtx.nodeSet.indexOf(val) &amp; 0) {&amp;br/&gt;					resultCtx.addNode(val);&amp;br/&gt;				}&amp;br/&gt;			});&amp;br/&gt;		}&amp;br/&gt;&amp;br/&gt;		return resultCtx;&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	op_numeric_operation(ctx, ast, operation) {&amp;br/&gt;		return this.numericOp(ctx, ast, function (values) {&amp;br/&gt;			let result = values.length&amp;br/&gt;				? (typeof (values[0]) === 'string' ? parseInt(values[0], 10) : values[0])&amp;br/&gt;				: 0;&amp;br/&gt;			for (var i = 1; i &amp; values.length; i++) {&amp;br/&gt;				var val = values[i];&amp;br/&gt;				val = typeof (val) === 'string' ? parseInt(val, 10) : val;&amp;br/&gt;				result = operation(result, val);&amp;br/&gt;			}&amp;br/&gt;			return result;&amp;br/&gt;		});&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	op_numeric_operation_add(ctx, ast) {&amp;br/&gt;		let add = (num1, num2) =&gt; num1 + num2;&amp;br/&gt;		return this.op_numeric_operation(ctx, ast, add);&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	op_numeric_operation_subtract(ctx, ast) {&amp;br/&gt;		let subtract = (num1, num2) =&gt; num1 - num2;&amp;br/&gt;		return this.op_numeric_operation(ctx, ast, subtract);&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	op_numeric_operation_multiply(ctx, ast) {&amp;br/&gt;		let multiply = (num1, num2) =&gt; num1 * num2;&amp;br/&gt;		return this.op_numeric_operation(ctx, ast, multiply);&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	op_numeric_operation_mod(ctx, ast) {&amp;br/&gt;		let mod = (num1, num2) =&gt; num1 % num2;&amp;br/&gt;		return this.op_numeric_operation(ctx, ast, mod);&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	op_numeric_operation_divide(ctx, ast) {&amp;br/&gt;		let divide = (num1, num2) =&gt; num1 / num2;&amp;br/&gt;		return this.op_numeric_operation(ctx, ast, divide);&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;&amp;br/&gt;	// FUNCTIONS&amp;br/&gt;&amp;br/&gt;	fn_contains(ctx, ast) {&amp;br/&gt;		return this.functionOp(ctx, ast, [{ type: types.STRING }, { type: types.STRING }], function (string1, string2) {&amp;br/&gt;			if (string1 && typeof(string1) !== 'string') {&amp;br/&gt;				string1 = string1.toString();&amp;br/&gt;			}&amp;br/&gt;			if (string1 && typeof(string1.indexOf) === 'function' && string1.indexOf(string2) &gt;= 0) {&amp;br/&gt;				return true;&amp;br/&gt;			}&amp;br/&gt;			return false;&amp;br/&gt;		});&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	fn_last(ctx, ast) {&amp;br/&gt;		return this.functionOp(ctx, ast, [], function () {&amp;br/&gt;			return ctx.nodeSet.length;&amp;br/&gt;		});&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	fn_name(ctx, ast) {&amp;br/&gt;		return this.functionOp(ctx, ast, [], function () {&amp;br/&gt;			const ctxNode = ctx.currentNode();&amp;br/&gt;			if (!ctxNode) {&amp;br/&gt;				return null;&amp;br/&gt;			}&amp;br/&gt;			if (isShadowRoot(ctxNode)) {&amp;br/&gt;				return nodeNames.SHADOW_ROOT;&amp;br/&gt;			}&amp;br/&gt;			return ctxNode.localName;&amp;br/&gt;		});&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	fn_not(ctx, ast) {&amp;br/&gt;		return this.functionOp(ctx, ast, [{ type: types.ANY }], function (value) {&amp;br/&gt;			if (value === false || value === null || value === undefined) {&amp;br/&gt;				return true;&amp;br/&gt;			}&amp;br/&gt;			return false;&amp;br/&gt;		});&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	fn_position(ctx, ast) {&amp;br/&gt;		return this.functionOp(ctx, ast, [], function () {&amp;br/&gt;			return ctx.currentPosition + 1;&amp;br/&gt;		});&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	fn_starts_with(ctx, ast) {&amp;br/&gt;		return this.functionOp(ctx, ast, [{ type: types.STRING }, { type: types.STRING }], function (string1, string2) {&amp;br/&gt;			if (string1 && typeof(string1) !== 'string') {&amp;br/&gt;				string1 = string1.toString();&amp;br/&gt;			}&amp;br/&gt;			if (string1 && typeof(string1.indexOf) === 'function' && string1.indexOf(string2) === 0) {&amp;br/&gt;				return true;&amp;br/&gt;			}&amp;br/&gt;			return false;&amp;br/&gt;		});&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	fn_normalize_space(ctx, ast) {&amp;br/&gt;		return this.functionOp(ctx, ast, [{ type: types.STRING, optional: true }], function (value) {&amp;br/&gt;			if (!value || !value.length) {&amp;br/&gt;				if (!ctx.currentNode()) {&amp;br/&gt;					ctx.nextNode();&amp;br/&gt;				}&amp;br/&gt;				value = resolveValue(ctx.currentNode(), types.STRING);&amp;br/&gt;			}&amp;br/&gt;			if (value && typeof (value) === 'string') {&amp;br/&gt;				return value.trim().replace(/\s+/g, ' ');&amp;br/&gt;			}&amp;br/&gt;			return null;&amp;br/&gt;		});&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	fn_text(ctx, ast) {&amp;br/&gt;		return this.functionOp(ctx, ast, [], function () {&amp;br/&gt;			!ctx.currentNode() ? ctx.nextNode() : null;&amp;br/&gt;			const node = ctx.currentNode();&amp;br/&gt;			return textNodesUnder(node);&amp;br/&gt;&amp;br/&gt;			function textNodesUnder(node) {&amp;br/&gt;				let allTextNodes = [];&amp;br/&gt;				for (node = node.firstChild; node; node = node.nextSibling) {&amp;br/&gt;					if (node.nodeType === 3) {&amp;br/&gt;						allTextNodes.push(node);&amp;br/&gt;					}&amp;br/&gt;				}&amp;br/&gt;				return allTextNodes;&amp;br/&gt;			}&amp;br/&gt;		});&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	fn_count(ctx, ast) {&amp;br/&gt;		return this.functionOp(ctx, ast, [{ type: types.SEQUENCE }], function (value) {&amp;br/&gt;			if (value && value.length) {&amp;br/&gt;				return value.length;&amp;br/&gt;			}&amp;br/&gt;			return 0;&amp;br/&gt;		});&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	fn_concat(ctx, ast) {&amp;br/&gt;		return this.functionOp(ctx, ast, ast.args, function () {&amp;br/&gt;			return Array.from(arguments).join('');&amp;br/&gt;		});&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	fn_translate(ctx, ast) {&amp;br/&gt;		return this.functionOp(ctx, ast, [{ type: types.STRING }, { type: types.STRING }, { type: types.STRING }], function (arg, mapString, transString) {&amp;br/&gt;			if (!mapString || mapString.length === 0 || !arg) {&amp;br/&gt;				return arg;&amp;br/&gt;			}&amp;br/&gt;			let resultString = '';&amp;br/&gt;			[...arg].forEach(ch =&gt; {&amp;br/&gt;				const mIndex = mapString.indexOf(ch);&amp;br/&gt;				if (mIndex &gt;= 0) {&amp;br/&gt;					if (transString.length &gt; mIndex) {&amp;br/&gt;						resultString += transString.charAt(mIndex);&amp;br/&gt;					}&amp;br/&gt;				} else {&amp;br/&gt;					resultString += ch;&amp;br/&gt;				}&amp;br/&gt;			});&amp;br/&gt;			return resultString;&amp;br/&gt;		});&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	fn_string_length(ctx, ast) {&amp;br/&gt;		return this.functionOp(ctx, ast, [{ type: types.STRING, optional: true }], function (value) {&amp;br/&gt;&amp;br/&gt;			if (!value) {&amp;br/&gt;				return 0;&amp;br/&gt;			}&amp;br/&gt;&amp;br/&gt;			if (value instanceof Array && value.length === 0) {&amp;br/&gt;				if (!ctx.currentNode()) {&amp;br/&gt;					ctx.nextNode();&amp;br/&gt;				}&amp;br/&gt;&amp;br/&gt;				const ctxNode = ctx.currentNode();&amp;br/&gt;				if (isElement(ctxNode)) {&amp;br/&gt;					return ctxNode.textContent ? ctxNode.textContent.length : 0;&amp;br/&gt;				}&amp;br/&gt;			}&amp;br/&gt;&amp;br/&gt;			return value.length;&amp;br/&gt;		});&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	// AXES&amp;br/&gt;&amp;br/&gt;	axis_ancestor(ctx) {&amp;br/&gt;		return this.makeAncestorIterator(ctx, 1, 99999);&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	axis_ancestor_or_self(ctx) {&amp;br/&gt;		return this.makeAncestorIterator(ctx, 0, 99999);&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	axis_attribute(ctx) {&amp;br/&gt;		return this.makeAttributeIterator(ctx);&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	axis_child(ctx) {&amp;br/&gt;		return this.makeDescendantIterator(ctx, 1, 1);&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	axis_descendant_or_self(ctx) {&amp;br/&gt;		return this.makeDescendantIterator(ctx, 0, 99999);&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	axis_descendant(ctx) {&amp;br/&gt;		return this.makeDescendantIterator(ctx, 1, 99999);&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	axis_following(ctx) {&amp;br/&gt;		return this.makeFollowingIterator(ctx, true);&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	axis_following_sibling(ctx) {&amp;br/&gt;		return this.makeSiblingIterator(ctx, true);&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	axis_parent(ctx) {&amp;br/&gt;		return this.makeAncestorIterator(ctx, 1, 1);&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	axis_preceding(ctx) {&amp;br/&gt;		return this.makePrecedingIterator(ctx, false);&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	axis_preceding_sibling(ctx) {&amp;br/&gt;		return this.makeSiblingIterator(ctx, false);&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	axis_self(ctx) {&amp;br/&gt;		return this.makeDescendantIterator(ctx, 0, 0);&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	// AXIS ITERSTORS&amp;br/&gt;&amp;br/&gt;	makeAncestorIterator(ctx, minDepth, maxDepth) {&amp;br/&gt;&amp;br/&gt;		let itState;&amp;br/&gt;&amp;br/&gt;		return function () {&amp;br/&gt;&amp;br/&gt;			let result = iterateNext();&amp;br/&gt;			while (result) {&amp;br/&gt;				if (itState.currentDepth &gt;= minDepth) {&amp;br/&gt;					break;&amp;br/&gt;				}&amp;br/&gt;				result = iterateNext();&amp;br/&gt;			}&amp;br/&gt;			return result;&amp;br/&gt;&amp;br/&gt;			function iterateNext() {&amp;br/&gt;&amp;br/&gt;				if (!itState) {&amp;br/&gt;					itState = nextCtx(itState, ctx);&amp;br/&gt;					itState.currentDepth = 0;&amp;br/&gt;					return itState.currentNode;&amp;br/&gt;				}&amp;br/&gt;&amp;br/&gt;				itState.currentNode = getParentNode(itState.currentNode);&amp;br/&gt;&amp;br/&gt;				if (itState.currentNode&amp;br/&gt;					&& itState.currentDepth &amp; maxDepth) {&amp;br/&gt;					itState.currentDepth++;&amp;br/&gt;					return itState.currentNode;&amp;br/&gt;				}&amp;br/&gt;&amp;br/&gt;				itState = nextCtx(itState, ctx);&amp;br/&gt;				return itState.currentNode;&amp;br/&gt;			}&amp;br/&gt;		}&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	makeAttributeIterator(ctx) {&amp;br/&gt;&amp;br/&gt;		let itState;&amp;br/&gt;&amp;br/&gt;		return function () {&amp;br/&gt;&amp;br/&gt;			if (!itState) {&amp;br/&gt;				itState = nextCtx(itState, ctx);&amp;br/&gt;				itState.attrIndex = -1;&amp;br/&gt;				itState.propIndex = -1;&amp;br/&gt;			}&amp;br/&gt;&amp;br/&gt;			while (itState.currentNode) {&amp;br/&gt;&amp;br/&gt;				itState.attrIndex++;&amp;br/&gt;				if (itState.currentNode instanceof Prop && typeof itState.currentNode.value === 'object') {&amp;br/&gt;					if (itState.propIndex &amp; 0) {&amp;br/&gt;						itState.currentKeys = Object.keys(itState.currentNode.value);&amp;br/&gt;					}&amp;br/&gt;				}&amp;br/&gt;				if (itState.currentNode.attributes&amp;br/&gt;					&& itState.currentNode.attributes.length &gt; itState.attrIndex) {&amp;br/&gt;					return itState.currentNode.attributes[itState.attrIndex];&amp;br/&gt;				}&amp;br/&gt;&amp;br/&gt;				if (itState.propIndex &amp; 0 && !(itState.currentNode instanceof Prop)) {&amp;br/&gt;					itState.currentKeys = Object.keys(itState.currentNode);&amp;br/&gt;					//					console.log(itState.currentNode instanceof HTMLElement);&amp;br/&gt;					if (Object.getPrototypeOf(itState.currentNode).constructor.name === 'HTMLBridgeElement') {&amp;br/&gt;						itState.currentKeys = itState.currentKeys.concat(Object.keys(Object.getPrototypeOf(Object.getPrototypeOf(itState.currentNode))));&amp;br/&gt;					}&amp;br/&gt;					else if (itState.currentNode instanceof HTMLElement) {&amp;br/&gt;						itState.currentKeys = itState.currentKeys.concat(Object.keys(Object.getPrototypeOf(itState.currentNode)));&amp;br/&gt;						//						console.log(itState.currentKeys);&amp;br/&gt;					}&amp;br/&gt;					&amp;br/&gt;					itState.currentKeys = itState.currentKeys.filter(e =&gt; !skipAttributeKeys[e]);&amp;br/&gt;				}&amp;br/&gt;				itState.propIndex++;&amp;br/&gt;				if (itState && itState.currentKeys && itState.currentKeys.length &gt; itState.propIndex) {&amp;br/&gt;					let propName = itState.currentKeys[itState.propIndex];&amp;br/&gt;					let propValue = null;&amp;br/&gt;					try {&amp;br/&gt;						if (itState.currentNode instanceof Prop) {&amp;br/&gt;							propValue = itState.currentNode.value[propName];&amp;br/&gt;						} else {&amp;br/&gt;							propValue = itState.currentNode[propName];&amp;br/&gt;						}&amp;br/&gt;					} catch (e) {&amp;br/&gt;					}&amp;br/&gt;&amp;br/&gt;&amp;br/&gt;					return new Prop(propName, propValue);&amp;br/&gt;				}&amp;br/&gt;				itState.attrIndex = -1;&amp;br/&gt;				itState.propIndex = -1;&amp;br/&gt;				itState = nextCtx(itState, ctx);&amp;br/&gt;			}&amp;br/&gt;			return null;&amp;br/&gt;		}&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	makeDescendantIterator(ctx, minDepth, maxDepth) {&amp;br/&gt;&amp;br/&gt;		let itState;&amp;br/&gt;&amp;br/&gt;		return function () {&amp;br/&gt;&amp;br/&gt;			let result = iterateNext();&amp;br/&gt;			while (result) {&amp;br/&gt;				if (itState.currentDepth &gt;= minDepth) {&amp;br/&gt;					break;&amp;br/&gt;				}&amp;br/&gt;				result = iterateNext();&amp;br/&gt;			}&amp;br/&gt;			return result;&amp;br/&gt;&amp;br/&gt;			function iterateNext() {&amp;br/&gt;&amp;br/&gt;				if (!itState) {&amp;br/&gt;					itState = nextCtx(itState, ctx);&amp;br/&gt;					itState.currentDepth = 0;&amp;br/&gt;					return itState.currentNode;&amp;br/&gt;				}&amp;br/&gt;&amp;br/&gt;				// Next process the current node's shadow tree, if any.&amp;br/&gt;				if (itState.currentNode.shadowRoot && itState.currentNode&amp;br/&gt;					&& itState.currentDepth &amp; maxDepth) {&amp;br/&gt;					itState.currentDepth++;&amp;br/&gt;					itState.currentNode = itState.currentNode.shadowRoot;&amp;br/&gt;					maxDepth += 1;&amp;br/&gt;					return itState.currentNode;&amp;br/&gt;				}&amp;br/&gt;&amp;br/&gt;				// Next process the current node's children.&amp;br/&gt;				if (itState.currentNode.firstChild&amp;br/&gt;					&& itState.currentDepth &amp; maxDepth) {&amp;br/&gt;					itState.currentDepth++;&amp;br/&gt;					itState.currentNode = itState.currentNode.firstChild;&amp;br/&gt;					return itState.currentNode;&amp;br/&gt;				} else if (itState.currentNode.localName === nodeNames.SLOT&amp;br/&gt;					&& itState.currentDepth &amp; maxDepth&amp;br/&gt;					&& slotHasAssignedNodes(itState.currentNode)) {&amp;br/&gt;					itState.currentDepth++;&amp;br/&gt;					const assignedNodes = itState.currentNode.assignedNodes();&amp;br/&gt;					itState.currentNode = assignedNodes[0];&amp;br/&gt;					return itState.currentNode;&amp;br/&gt;				}&amp;br/&gt;&amp;br/&gt;				// Move on to the next sibling node, if any.&amp;br/&gt;				if (itState.currentDepth &gt; 0 && itState.currentNode.nextSibling) {&amp;br/&gt;					if (hasSameOrNoSlot(itState.currentNode)) {&amp;br/&gt;						itState.currentNode = itState.currentNode.nextSibling;&amp;br/&gt;						return itState.currentNode;&amp;br/&gt;					}&amp;br/&gt;				} else if (itState.currentNode.parentNode &&&amp;br/&gt;					itState.currentNode.parentNode.localName === nodeNames.SLOT&amp;br/&gt;					&& slotHasAssignedNodes(itState.currentNode.parentNode)) {&amp;br/&gt;					itState.currentNode = itState.currentNode.parentNode.assignedNodes()[0];&amp;br/&gt;					return itState.currentNode;&amp;br/&gt;				}&amp;br/&gt;&amp;br/&gt;				// We have finished traversing the all the elements at the current depth:&amp;br/&gt;				// - continue processing the parent.&amp;br/&gt;				while (itState.currentDepth &gt;= 0) {&amp;br/&gt;					itState.currentDepth = itState.currentDepth == 0 ? 0 : itState.currentDepth - 1;&amp;br/&gt;					if (itState.currentDepth == 0) {&amp;br/&gt;						itState = nextCtx(itState, ctx);&amp;br/&gt;						return itState.currentNode;&amp;br/&gt;					}&amp;br/&gt;					else {&amp;br/&gt;						itState.currentNode = getParentNode(itState.currentNode);&amp;br/&gt;						const nextSibling = getNextSibling(itState.currentNode);&amp;br/&gt;						if (nextSibling) {&amp;br/&gt;							itState.currentNode = nextSibling;&amp;br/&gt;							return itState.currentNode;&amp;br/&gt;						}&amp;br/&gt;					}&amp;br/&gt;				}&amp;br/&gt;&amp;br/&gt;				return null;&amp;br/&gt;			}&amp;br/&gt;		}&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	makeFollowingIterator(ctx) {&amp;br/&gt;&amp;br/&gt;		let itState;&amp;br/&gt;&amp;br/&gt;		return function () {&amp;br/&gt;&amp;br/&gt;			if (!itState) {&amp;br/&gt;				nextParent();&amp;br/&gt;				return itState.currentNode;&amp;br/&gt;			}&amp;br/&gt;&amp;br/&gt;			// Process the current node's children.&amp;br/&gt;			if (itState.currentNode.firstChild) {&amp;br/&gt;				itState.currentNode = itState.currentNode.firstChild;&amp;br/&gt;				return itState.currentNode;&amp;br/&gt;			}&amp;br/&gt;&amp;br/&gt;			// Move on to the next sibling node, if any.&amp;br/&gt;			if (itState.currentNode.nextSibling) {&amp;br/&gt;				itState.currentNode = itState.currentNode.nextSibling;&amp;br/&gt;				return itState.currentNode;&amp;br/&gt;			}&amp;br/&gt;&amp;br/&gt;			// We have finished traversing the all the elements at the current level:&amp;br/&gt;			// - continue processing the parent.&amp;br/&gt;			nextParent();&amp;br/&gt;			return itState.currentNode;&amp;br/&gt;&amp;br/&gt;			function nextParent() {&amp;br/&gt;&amp;br/&gt;				if (!itState) {&amp;br/&gt;					itState = nextCtx(itState, ctx);&amp;br/&gt;				}&amp;br/&gt;&amp;br/&gt;				while (itState.currentNode && !itState.currentNode.nextSibling) {&amp;br/&gt;					if (itState.currentNode.parentNode) {&amp;br/&gt;						itState.currentNode = itState.currentNode.parentNode;&amp;br/&gt;					}&amp;br/&gt;					else {&amp;br/&gt;						itState = nextCtx(itState, ctx);&amp;br/&gt;					}&amp;br/&gt;				}&amp;br/&gt;&amp;br/&gt;				if (itState.currentNode) {&amp;br/&gt;					itState.currentNode = itState.currentNode.nextSibling;&amp;br/&gt;				}&amp;br/&gt;&amp;br/&gt;			}&amp;br/&gt;		}&amp;br/&gt;&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	makePrecedingIterator(ctx) {&amp;br/&gt;&amp;br/&gt;		let itState;&amp;br/&gt;&amp;br/&gt;		return function () {&amp;br/&gt;			if (!itState) {&amp;br/&gt;				nextParent();&amp;br/&gt;				return itState.currentNode;&amp;br/&gt;			}&amp;br/&gt;&amp;br/&gt;			if (itState.currentNode.previousSibling) {&amp;br/&gt;				itState.currentNode = itState.currentNode.previousSibling;&amp;br/&gt;				while (itState.currentNode.lastChild) {&amp;br/&gt;					itState.currentNode = itState.currentNode.lastChild;&amp;br/&gt;				}&amp;br/&gt;&amp;br/&gt;				return itState.currentNode;&amp;br/&gt;			}&amp;br/&gt;&amp;br/&gt;			nextParent();&amp;br/&gt;			return itState.currentNode;&amp;br/&gt;&amp;br/&gt;			function nextParent() {&amp;br/&gt;&amp;br/&gt;				if (itState && itState.currentNode) {&amp;br/&gt;					if (!itState.currentNode.parentNode) {&amp;br/&gt;						itState.currentNode = null;&amp;br/&gt;						return itState.currentNode;&amp;br/&gt;					}&amp;br/&gt;&amp;br/&gt;					itState.currentNode = itState.currentNode.parentNode;&amp;br/&gt;&amp;br/&gt;					if (!itState.currentNode.contains(itState.rootCtxNode)) {&amp;br/&gt;						return itState.currentNode;&amp;br/&gt;					}&amp;br/&gt;&amp;br/&gt;					if (itState.currentNode.previousSibling) {&amp;br/&gt;						itState.currentNode = itState.currentNode.previousSibling;&amp;br/&gt;						while (itState.currentNode.lastChild) {&amp;br/&gt;							itState.currentNode = itState.currentNode.lastChild;&amp;br/&gt;						}&amp;br/&gt;						return itState.currentNode;&amp;br/&gt;					}&amp;br/&gt;				}&amp;br/&gt;&amp;br/&gt;&amp;br/&gt;				itState = nextCtx(itState, ctx);&amp;br/&gt;				itState.rootCtxNode = itState.currentNode;&amp;br/&gt;				while (itState.currentNode && !itState.currentNode.previousSibling) {&amp;br/&gt;					itState.currentNode = itState.currentNode.parentNode;&amp;br/&gt;				}&amp;br/&gt;				if (itState.currentNode) {&amp;br/&gt;					itState.currentNode = itState.currentNode.previousSibling;&amp;br/&gt;					while (itState.currentNode.lastChild) {&amp;br/&gt;						itState.currentNode = itState.currentNode.lastChild;&amp;br/&gt;					}&amp;br/&gt;				}&amp;br/&gt;&amp;br/&gt;				return itState.currentNode;&amp;br/&gt;			}&amp;br/&gt;		}&amp;br/&gt;&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	makeSiblingIterator(ctx, following) {&amp;br/&gt;&amp;br/&gt;		let itState;&amp;br/&gt;&amp;br/&gt;		return function () {&amp;br/&gt;&amp;br/&gt;			if (!itState) {&amp;br/&gt;				itState = nextCtx(itState, ctx);&amp;br/&gt;			}&amp;br/&gt;&amp;br/&gt;			if (itState.currentNode == null) {&amp;br/&gt;				return null;&amp;br/&gt;			}&amp;br/&gt;&amp;br/&gt;			itState.currentNode = following ? itState.currentNode.nextElementSibling : itState.currentNode.previousElementSibling;&amp;br/&gt;			return itState.currentNode;&amp;br/&gt;		}&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;&amp;br/&gt;	// UTILITY&amp;br/&gt;&amp;br/&gt;	comparisonOp(ctx, ast, operatorImpl) {&amp;br/&gt;&amp;br/&gt;		// Resolve the left and right values.&amp;br/&gt;		let leftValue = this.executeInternal(ctx, ast.exprs[0]);&amp;br/&gt;		let rightValue = this.executeInternal(ctx, ast.exprs[1]);&amp;br/&gt;&amp;br/&gt;		// Convert both to arrays.&amp;br/&gt;		leftValue = toArray(leftValue);&amp;br/&gt;		rightValue = toArray(rightValue);&amp;br/&gt;&amp;br/&gt;		// Compare all the left and right values, returning true if&amp;br/&gt;		// any match.&amp;br/&gt;		for (var l = 0; l &amp; leftValue.length; l++) {&amp;br/&gt;			let leftResolved = resolveValue(leftValue[l], types.ANY);&amp;br/&gt;			for (var r = 0; r &amp; rightValue.length; r++) {&amp;br/&gt;				let rightResolved = resolveValue(rightValue[r], types.ANY);&amp;br/&gt;				if (operatorImpl(leftResolved, rightResolved) === true) {&amp;br/&gt;					return true;&amp;br/&gt;				}&amp;br/&gt;			}&amp;br/&gt;		}&amp;br/&gt;		for (var r = leftValue.length; r &amp; rightValue.length; r++) {&amp;br/&gt;			let rightResolved = resolveValue(rightValue[r], types.ANY);&amp;br/&gt;			if (operatorImpl(null, rightResolved) === true) {&amp;br/&gt;				return true;&amp;br/&gt;			}&amp;br/&gt;		}&amp;br/&gt;&amp;br/&gt;		return false;&amp;br/&gt;&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	numericOp(ctx, ast, operatorImpl) {&amp;br/&gt;		const values = [];&amp;br/&gt;		ast.exprs.forEach(expr =&gt; {&amp;br/&gt;			values.push(toArray(this.executeInternal(ctx, expr)));&amp;br/&gt;		});&amp;br/&gt;&amp;br/&gt;		for (var i = 0; i &amp; values.length; i++) {&amp;br/&gt;			values[i] = resolveValue(values[i][0], types.STRING);&amp;br/&gt;		}&amp;br/&gt;&amp;br/&gt;		return operatorImpl(values);&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	functionOp(ctx, ast, argDescrs, functionImpl) {&amp;br/&gt;&amp;br/&gt;		// Check that the required number args have been supplied.&amp;br/&gt;		if (!ast.args) {&amp;br/&gt;			ast.args = [];&amp;br/&gt;		}&amp;br/&gt;		if (!ast.args || argDescrs != null && argDescrs.length != ast.args.length) {&amp;br/&gt;			const mandatoryArgsDesc = argDescrs.filter(argDesc =&gt; !argDesc.optional);&amp;br/&gt;			if (mandatoryArgsDesc.length != ast.args.length) {&amp;br/&gt;				return false;&amp;br/&gt;			}&amp;br/&gt;		}&amp;br/&gt;&amp;br/&gt;		let args = [];&amp;br/&gt;		for (var a = 0; a &amp; ast.args.length; a++) {&amp;br/&gt;			let arg = this.executeInternal(ctx, ast.args[a]);&amp;br/&gt;			arg = toArray(arg);&amp;br/&gt;			args.push(arg);&amp;br/&gt;		}&amp;br/&gt;&amp;br/&gt;		let result = recurse(args, 0, [], functionImpl);&amp;br/&gt;		return result;&amp;br/&gt;&amp;br/&gt;		function recurse(args, depth, resolvedArgs, functionImpl) {&amp;br/&gt;&amp;br/&gt;			if (depth &gt;= args.length) {&amp;br/&gt;				// Only happens for no-arg functions.&amp;br/&gt;				return functionImpl([]);&amp;br/&gt;			}&amp;br/&gt;			// Support for functions that takes sequences as arguments&amp;br/&gt;			if (argDescrs.length === 1 && argDescrs[0].type === types.SEQUENCE) {&amp;br/&gt;				return functionImpl.apply(null, [resolveValue(args[0], types.ANY)]);&amp;br/&gt;			}&amp;br/&gt;&amp;br/&gt;			let results = [];&amp;br/&gt;			for (var a = 0; a == 0 || a &amp; args[depth].length; a++) {&amp;br/&gt;				resolvedArgs[depth] = resolveValue(args[depth][a], argDescrs[depth].type);&amp;br/&gt;&amp;br/&gt;				let result;&amp;br/&gt;				if (depth == args.length - 1) {&amp;br/&gt;					result = functionImpl.apply(null, resolvedArgs);&amp;br/&gt;				}&amp;br/&gt;				else {&amp;br/&gt;					result = recurse(args, depth + 1, resolvedArgs, functionImpl);&amp;br/&gt;				}&amp;br/&gt;&amp;br/&gt;				if (result) {&amp;br/&gt;					results.push(result);&amp;br/&gt;				}&amp;br/&gt;			}&amp;br/&gt;&amp;br/&gt;			if (results.length == 0) {&amp;br/&gt;				return null;&amp;br/&gt;			}&amp;br/&gt;			else if (results.length == 1) {&amp;br/&gt;				return results[0]&amp;br/&gt;			}&amp;br/&gt;			return results;&amp;br/&gt;		}&amp;br/&gt;&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	expressionOp(ctx, expr) {&amp;br/&gt;		let exprResult = toArray(this.executeInternal(ctx, expr));&amp;br/&gt;		exprResult.forEach(val =&gt; {&amp;br/&gt;			val = resolveValue(val, types.BOOLEAN);&amp;br/&gt;		});&amp;br/&gt;		return exprResult.some(e =&gt; e);&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	applyFilters(ast, matchCtx) {&amp;br/&gt;		// Apply each filter to the nodes in turn&amp;br/&gt;		let filteredCtx = matchCtx;&amp;br/&gt;		if (ast.filters && filteredCtx.nodeSet.length &gt; 0) {&amp;br/&gt;			for (var f = 0, fLen = ast.filters.length; f &amp; fLen; f++) {&amp;br/&gt;				let sourceCtx = filteredCtx;&amp;br/&gt;				filteredCtx = new Context();&amp;br/&gt;				while (sourceCtx.nextNode()) {&amp;br/&gt;					let filterOutcome = this.executeInternal(sourceCtx, ast.filters[f]);&amp;br/&gt;&amp;br/&gt;					// Apply positional filters.&amp;br/&gt;					if (filterOutcome && !isNaN(parseInt(filterOutcome))) {&amp;br/&gt;						let filterPosition = parseInt(filterOutcome);&amp;br/&gt;						filterOutcome = filterPosition === sourceCtx.currentPosition + 1;&amp;br/&gt;					}&amp;br/&gt;&amp;br/&gt;					if (!filterOutcome&amp;br/&gt;						|| (filterOutcome instanceof Array && filterOutcome.length === 0)&amp;br/&gt;						|| (filterOutcome instanceof Context && filterOutcome.nodeSet.length === 0)) {&amp;br/&gt;						// skip&amp;br/&gt;					}&amp;br/&gt;					else {&amp;br/&gt;						if (sourceCtx.currentNode() instanceof Prop) {&amp;br/&gt;							filteredCtx.addNode(filterOutcome.nextNode());&amp;br/&gt;						}	else {&amp;br/&gt;							filteredCtx.addNode(sourceCtx.currentNode());&amp;br/&gt;						}&amp;br/&gt;					}&amp;br/&gt;				}&amp;br/&gt;			}&amp;br/&gt;		}&amp;br/&gt;		return filteredCtx;&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;}&amp;br/&gt;&amp;br/&gt;function resolveValue(value, type) {&amp;br/&gt;&amp;br/&gt;	if (isAttr(value) || isProp(value)) {&amp;br/&gt;		if (type === types.BOOLEAN) {&amp;br/&gt;			return true;&amp;br/&gt;		}&amp;br/&gt;		if (typeof value.value === 'boolean') {&amp;br/&gt;			return value.value.toString();&amp;br/&gt;		}&amp;br/&gt;		return value.value;&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	if (isElement(value) && value.localName === nodeNames.SLOT) {&amp;br/&gt;		if (type === types.STRING) {&amp;br/&gt;			return getSlotTextContent(value);&amp;br/&gt;		}&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	if (isTextNode(value)) {&amp;br/&gt;		if (type === types.BOOLEAN) {&amp;br/&gt;			return true;&amp;br/&gt;		}&amp;br/&gt;		if (type === types.STRING) {&amp;br/&gt;			return value.textContent;&amp;br/&gt;		}&amp;br/&gt;		return value;&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	if (isElement(value)) {&amp;br/&gt;		if (type === types.BOOLEAN) {&amp;br/&gt;			return true;&amp;br/&gt;		}&amp;br/&gt;		if (type === types.STRING) {&amp;br/&gt;			return getContextTextContent(value);&amp;br/&gt;		}&amp;br/&gt;		return value;&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	if (value instanceof Array) {&amp;br/&gt;		if (type === types.BOOLEAN) {&amp;br/&gt;			return value.length &gt; 0;&amp;br/&gt;		}&amp;br/&gt;		if (type === types.STRING) {&amp;br/&gt;			return value.toString();&amp;br/&gt;		}&amp;br/&gt;		return value;&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	if (type === types.BOOLEAN) {&amp;br/&gt;		return value !== null && value !== undefined && value !== false;&amp;br/&gt;	}&amp;br/&gt;	&amp;br/&gt;	if (type === types.STRING) {&amp;br/&gt;		return value == null || value === undefined ? '' : value;&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	return value;&amp;br/&gt;}&amp;br/&gt;&amp;br/&gt;function getContextTextContent(element) {&amp;br/&gt;	var treeWalker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT, null);&amp;br/&gt;	const textNodes = [''];&amp;br/&gt;	while (true) {&amp;br/&gt;		const textNode = treeWalker.nextNode();&amp;br/&gt;		if (!textNode) {&amp;br/&gt;			break;&amp;br/&gt;		}&amp;br/&gt;		textNodes.push(textNode.textContent);&amp;br/&gt;	}&amp;br/&gt;	return textNodes.join('');&amp;br/&gt;}&amp;br/&gt;&amp;br/&gt;function sort(ctx) {&amp;br/&gt;&amp;br/&gt;	ctx.nodeSet.sort(function (e1, e2) {&amp;br/&gt;&amp;br/&gt;		if (!e1.compareDocumentPosition && isAttr(e1)) {&amp;br/&gt;			e1 = e1.ownerElement;&amp;br/&gt;		}&amp;br/&gt;		if (!e2.compareDocumentPosition && isAttr(e2)) {&amp;br/&gt;			e2 = e2.ownerElement;&amp;br/&gt;		}&amp;br/&gt;&amp;br/&gt;		let position = null;&amp;br/&gt;		const parentNodes = compareAndGetParentNodes(e1, e2);&amp;br/&gt;		if (parentNodes && parentNodes.parentElem1 && parentNodes.parentElem2) {&amp;br/&gt;			const { parentElem1, parentElem2 } = parentNodes;&amp;br/&gt;			position = parentElem1.compareDocumentPosition(parentElem2);&amp;br/&gt;		} else {&amp;br/&gt;			position = e1.compareDocumentPosition(e2);&amp;br/&gt;		}&amp;br/&gt;&amp;br/&gt;		if (position & Node.DOCUMENT_POSITION_FOLLOWING || position & Node.DOCUMENT_POSITION_CONTAINED_BY) {&amp;br/&gt;			return -1;&amp;br/&gt;		} else if (position & Node.DOCUMENT_POSITION_PRECEDING || position & Node.DOCUMENT_POSITION_CONTAINS) {&amp;br/&gt;			return 1;&amp;br/&gt;		} else {&amp;br/&gt;			return 0;&amp;br/&gt;		}&amp;br/&gt;&amp;br/&gt;	});&amp;br/&gt;}&amp;br/&gt;&amp;br/&gt;function nextCtx(itState, ctx) {&amp;br/&gt;&amp;br/&gt;	if (!itState) {&amp;br/&gt;		itState =&amp;br/&gt;		{&amp;br/&gt;			ctxIndex: -1&amp;br/&gt;			, currentNode: null&amp;br/&gt;		}&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	itState.ctxIndex++;&amp;br/&gt;	if (ctx instanceof Function) {&amp;br/&gt;		itState.currentNode = ctx();&amp;br/&gt;	}&amp;br/&gt;	//	else if (ctx instanceof Context) {&amp;br/&gt;	//		itState.currentNode =  ctx.nextNode();&amp;br/&gt;	//	}&amp;br/&gt;	else {&amp;br/&gt;		itState.currentNode = itState.ctxIndex == 0 ? ctx : null;&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	return itState;&amp;br/&gt;}&amp;br/&gt;&amp;br/&gt;function toArray(value) {&amp;br/&gt;	if (value instanceof Context) {&amp;br/&gt;		return value.nodeSet;&amp;br/&gt;	}&amp;br/&gt;	if (!(value instanceof Array)) {&amp;br/&gt;		return [value];&amp;br/&gt;	}&amp;br/&gt;	return value;&amp;br/&gt;}&amp;br/&gt;&amp;br/&gt;function isElement(node) {&amp;br/&gt;	return node && node.nodeType === Node.ELEMENT_NODE;&amp;br/&gt;}&amp;br/&gt;&amp;br/&gt;function isAttr(node) {&amp;br/&gt;	return node && node.ownerElement;&amp;br/&gt;}&amp;br/&gt;&amp;br/&gt;function isProp(node) {&amp;br/&gt;	return node instanceof Prop;&amp;br/&gt;}&amp;br/&gt;&amp;br/&gt;function isTextNode(node) {&amp;br/&gt;	return node && node.nodeType === 3;&amp;br/&gt;}&amp;br/&gt;&amp;br/&gt;function isShadowRoot(node) {&amp;br/&gt;	return (node instanceof ShadowRoot || !node.parentNode) && node.host;&amp;br/&gt;}&amp;br/&gt;&amp;br/&gt;function getDocument(node) {&amp;br/&gt;	while (true) {&amp;br/&gt;		if (node.nodeName === nodeNames.DOCUMENT || (node.nodeName === nodeNames.HTML && !node.parentNode)) {&amp;br/&gt;			return node;&amp;br/&gt;		}&amp;br/&gt;		node = isShadowRoot(node) ? node.host : node.parentNode;&amp;br/&gt;	}&amp;br/&gt;}&amp;br/&gt;&amp;br/&gt;function isSlotWithSuppliedContent(node) {&amp;br/&gt;&amp;br/&gt;	if (!isElement(node) || node.localName !== nodeNames.SLOT) {&amp;br/&gt;		return false;&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	// Find the hosting element&amp;br/&gt;	let shadowRoot = node.parentNode;&amp;br/&gt;	while (shadowRoot && !shadowRoot.host) {&amp;br/&gt;		shadowRoot = shadowRoot.parentNode;&amp;br/&gt;	}&amp;br/&gt;	if (!shadowRoot) {&amp;br/&gt;		return false;&amp;br/&gt;	}&amp;br/&gt;	let host = shadowRoot.host;&amp;br/&gt;&amp;br/&gt;	// Get the slot name, if any.&amp;br/&gt;	let slotName = node.getAttribute('name');&amp;br/&gt;&amp;br/&gt;	let hostChild = host.firstChild;&amp;br/&gt;	while (hostChild) {&amp;br/&gt;		if (isElement(hostChild)) {&amp;br/&gt;			if (hostChild.getAttribute('slot') === slotName) {&amp;br/&gt;				return true;&amp;br/&gt;			}&amp;br/&gt;		}&amp;br/&gt;		else if (!slotName) {&amp;br/&gt;			// Text nodes count as content for the unnamed slot.&amp;br/&gt;			return true;&amp;br/&gt;		}&amp;br/&gt;		hostChild = hostChild.nextSibling;&amp;br/&gt;	}&amp;br/&gt;	return false;&amp;br/&gt;}&amp;br/&gt;&amp;br/&gt;function nextSiblingForSuppliedContent(node) {&amp;br/&gt;	const host = node.parentNode;&amp;br/&gt;	let childIndex = -1;&amp;br/&gt;	for (let i = 0; i &amp; host.childElementCount; i++) {&amp;br/&gt;		if (host.children[i] == node) {&amp;br/&gt;			childIndex = i;&amp;br/&gt;			break;&amp;br/&gt;		}&amp;br/&gt;	}&amp;br/&gt;	if (childIndex &gt;= 0 && childIndex + 1 &amp; host.childElementCount) {&amp;br/&gt;		return host.children[childIndex + 1];&amp;br/&gt;	}&amp;br/&gt;	return null;&amp;br/&gt;}&amp;br/&gt;&amp;br/&gt;function slotHasAssignedNodes(node) {&amp;br/&gt;	const assignedNodes = node.assignedNodes();&amp;br/&gt;	return assignedNodes && assignedNodes.length &gt; 0;&amp;br/&gt;}&amp;br/&gt;&amp;br/&gt;function getSlotTextContent(node) {&amp;br/&gt;	if (slotHasAssignedNodes(node)) {&amp;br/&gt;		const textContent = node.assignedNodes().reduce((t, e) =&gt; t += e.nodeType === Node.TEXT_NODE ? e.textContent : '', '');&amp;br/&gt;		if (textContent) {&amp;br/&gt;			return textContent;&amp;br/&gt;		}&amp;br/&gt;	}&amp;br/&gt;	return node.textContent;&amp;br/&gt;}&amp;br/&gt;&amp;br/&gt;function getParentNode(currentNode) {&amp;br/&gt;	if (!currentNode) {&amp;br/&gt;		return;&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	if (currentNode.assignedSlot) {&amp;br/&gt;		return currentNode.assignedSlot;&amp;br/&gt;	} else if (currentNode.nodeName === nodeNames.DOCUMENT_FRAGMENT) {&amp;br/&gt;		return currentNode.host;&amp;br/&gt;	} else {&amp;br/&gt;		return currentNode.parentNode;&amp;br/&gt;	}&amp;br/&gt;}&amp;br/&gt;&amp;br/&gt;function getNextSibling(currentNode) {&amp;br/&gt;	if (!currentNode) {&amp;br/&gt;		return;&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	if ((currentNode.nodeName === nodeNames.DOCUMENT_FRAGMENT)) {&amp;br/&gt;		const childNodes = Array.from(currentNode.host.childNodes);&amp;br/&gt;		if (childNodes && childNodes.length &gt; 0) {&amp;br/&gt;			const childNode = childNodes.find(childNode =&gt; !childNode.assignedSlot);&amp;br/&gt;			if (childNode) {&amp;br/&gt;				return childNode;&amp;br/&gt;			}&amp;br/&gt;		}&amp;br/&gt;	} else if (currentNode.nextSibling) {&amp;br/&gt;		if (currentNode.assignedSlot) {&amp;br/&gt;			return getNextSiblingInsideSlot(currentNode);&amp;br/&gt;		}&amp;br/&gt;		let nextSibling = currentNode.nextSibling;&amp;br/&gt;		while (nextSibling) {&amp;br/&gt;			if (!nextSibling.assignedSlot) {&amp;br/&gt;				return nextSibling;&amp;br/&gt;			}&amp;br/&gt;			nextSibling = nextSibling.nextSibling;&amp;br/&gt;		}&amp;br/&gt;	}&amp;br/&gt;}&amp;br/&gt;&amp;br/&gt;function getNextSiblingInsideSlot(currentNode) {&amp;br/&gt;	const slotElem = currentNode.assignedSlot;&amp;br/&gt;	const children = slotElem.assignedNodes();&amp;br/&gt;	const indexOfCurrentNode = children.indexOf(currentNode);&amp;br/&gt;	if (children.length - 1 === indexOfCurrentNode) {&amp;br/&gt;		return null;&amp;br/&gt;	} else {&amp;br/&gt;		return children[indexOfCurrentNode + 1];&amp;br/&gt;	}&amp;br/&gt;}&amp;br/&gt;&amp;br/&gt;function hasSameOrNoSlot(currentNode) {&amp;br/&gt;	const nextSibling = currentNode.nextSibling || {};&amp;br/&gt;	const haveNoSlot = !currentNode.assignedSlot && !nextSibling.assignedSlot;&amp;br/&gt;	const haveSameSlot = currentNode.assignedSlot === nextSibling.assignedSlot;&amp;br/&gt;	return haveNoSlot || haveSameSlot;&amp;br/&gt;}&amp;br/&gt;&amp;br/&gt;function listParentNodes(node) {&amp;br/&gt;	let parentNodes = [];&amp;br/&gt;	while (node) {&amp;br/&gt;		if (node.nodeName === '#document-fragment') {&amp;br/&gt;			node = node.host;&amp;br/&gt;			continue;&amp;br/&gt;		}&amp;br/&gt;		if (node.assignedSlot) {&amp;br/&gt;			node = node.assignedSlot;&amp;br/&gt;			continue;&amp;br/&gt;		}&amp;br/&gt;		parentNodes.unshift(node);&amp;br/&gt;		node = node.parentNode;&amp;br/&gt;	}&amp;br/&gt;	return parentNodes;&amp;br/&gt;}&amp;br/&gt;&amp;br/&gt;function compareAndGetParentNodes(node1, node2) {&amp;br/&gt;	let parents1 = listParentNodes(node1);&amp;br/&gt;	let parents2 = listParentNodes(node2);&amp;br/&gt;&amp;br/&gt;	if (parents1[0] !== parents2[0]) {&amp;br/&gt;		return null;&amp;br/&gt;	}&amp;br/&gt;&amp;br/&gt;	for (let i = 0; i &amp; parents1.length; i++) {&amp;br/&gt;		if (parents1[i] !== parents2[i]) {&amp;br/&gt;			return {&amp;br/&gt;				parentElem1: parents1[i],&amp;br/&gt;				parentElem2: parents2[i]&amp;br/&gt;			}&amp;br/&gt;		};&amp;br/&gt;	}&amp;br/&gt;	return null;&amp;br/&gt;}&amp;br/&gt;&amp;br/&gt;&amp;br/&gt;&amp;br/&gt;&amp;br/&gt;&amp;br/&gt;&amp;br/&gt;&amp;br/&gt;&amp;br/&gt;&amp;br/&gt;&amp;br/&gt;&amp;br/&gt;&amp;br/&gt;&amp;br/&gt;&amp;br/&gt;&amp;br/&gt;&amp;br/&gt;&amp;br/&gt;&amp;br/&gt;&amp;br/&gt;&amp;br/&gt;&amp;br/&gt;&amp;br/&gt;&amp;br/&gt;&amp;br/&gt;const contextNode = arguments[0];&amp;br/&gt;const ast = arguments[1];&amp;br/&gt;const result = new XpathAstExecutor().evaluate(contextNode, ast);&amp;br/&gt;console.log(result);&amp;br/&gt;return result;&amp;br/&gt;}, args=[{element-6066-11e4-a52e-4f735466cecf=f.A91DC468AC4DE00B1D033A0CB45D6F4E.d.04DC613C9C81222751B34C9BE871EF64.e.617}, {type=NodeSet, nodes=[{type=DeepPath}, {name=*, type=Node, filters=[{type=OpExpression, exprs=[{args=[{type=NodeSet, nodes=[{name=@class, type=Node}]}, {type=Literal, value='active'}], type=FunctionCall, function=contains}, {type=UnaryOpExpression, operator=(, expr={type=OpExpression, exprs=[{type=UnaryOpExpression, operator=(, expr={type=OpExpression, exprs=[{args=[{type=NodeSet, nodes=[{name=@class, type=Node}]}, {type=Literal, value='open'}], type=FunctionCall, function=contains}, {type=UnaryOpExpression, operator=(, expr={type=OpExpression, exprs=[{args=[{type=NodeSet, nodes=[{name=@class, type=Node}]}, {type=Literal, value='forceModal'}], type=FunctionCall, function=contains}, {args=[{type=NodeSet, nodes=[{name=@class, type=Node}]}, {type=Literal, value='uiModal'}], type=FunctionCall, function=contains}], operator=or}}], operator=and}}, {type=UnaryOpExpression, operator=(, expr={type=OpExpression, exprs=[{type=NodeSet, nodes=[{name=section, axis=self, type=Node}]}, {type=UnaryOpExpression, operator=(, expr={type=OpExpression, exprs=[{type=UnaryOpExpression, operator=(, expr={type=OpExpression, exprs=[{args=[{type=NodeSet, nodes=[{name=@class, type=Node}]}, {type=Literal, value='oneConsoleTab'}], type=FunctionCall, function=contains}, {type=NodeSet, nodes=[{name=div, filters=[{type=OpExpression, exprs=[{type=OpExpression, exprs=[{args=[{type=NodeSet, nodes=[{name=@class, type=Node}]}, {type=Literal, value='active'}], type=FunctionCall, function=contains}, {type=UnaryOpExpression, operator=(, expr={type=OpExpression, exprs=[{args=[{type=NodeSet, nodes=[{name=@class, type=Node}]}, {type=Literal, value='oneWorkspace'}], type=FunctionCall, function=contains}, {args=[{type=NodeSet, nodes=[{name=@class, type=Node}]}, {type=Literal, value='navexWorkspace'}], type=FunctionCall, function=contains}], operator=or}}], operator=and}, {args=[{type=OpExpression, exprs=[{args=[{type=NodeSet, nodes=[{name=@class, type=Node}]}, {type=Literal, value='hasPinnedRegionTemplate'}], type=FunctionCall, function=contains}, {args=[{type=NodeSet, nodes=[{name=@class, type=Node}]}, {type=Literal, value='hasActiveSubtab'}], type=FunctionCall, function=contains}], operator=and}], type=FunctionCall, function=not}], operator=and}], axis=ancestor, type=Node}]}], operator=and}}, {type=UnaryOpExpression, operator=(, expr={type=OpExpression, exprs=[{type=OpExpression, exprs=[{args=[{type=NodeSet, nodes=[{name=@class, type=Node}]}, {type=Literal, value='tabContent'}], type=FunctionCall, function=contains}, {type=NodeSet, nodes=[{name=div, filters=[{type=OpExpression, exprs=[{args=[{type=NodeSet, nodes=[{name=@class, type=Node}]}, {type=Literal, value='wsTabset'}], type=FunctionCall, function=contains}, {args=[{args=[{type=NodeSet, nodes=[{name=@class, type=Node}]}, {type=Literal, value='wsTabBarHidden'}], type=FunctionCall, function=contains}], type=FunctionCall, function=not}], operator=and}], axis=ancestor, type=Node}]}], operator=and}, {type=NodeSet, nodes=[{name=div, filters=[{type=OpExpression, exprs=[{type=OpExpression, exprs=[{type=OpExpression, exprs=[{args=[{type=NodeSet, nodes=[{name=@class, type=Node}]}, {type=Literal, value='active'}], type=FunctionCall, function=contains}, {type=UnaryOpExpression, operator=(, expr={type=OpExpression, exprs=[{args=[{type=NodeSet, nodes=[{name=@class, type=Node}]}, {type=Literal, value='oneWorkspace'}], type=FunctionCall, function=contains}, {args=[{type=NodeSet, nodes=[{name=@class, type=Node}]}, {type=Literal, value='navexWorkspace'}], type=FunctionCall, function=contains}], operator=or}}], operator=and}, {args=[{type=NodeSet, nodes=[{name=@class, type=Node}]}, {type=Literal, value='hasPinnedRegionTemplate'}], type=FunctionCall, function=contains}], operator=and}, {args=[{type=NodeSet, nodes=[{name=@class, type=Node}]}, {type=Literal, value='hasActiveSubtab'}], type=FunctionCall, function=contains}], operator=and}], axis=ancestor, type=Node}]}], operator=and}}], operator=or}}], operator=and}}], operator=or}}], operator=and}]}, {type=DeepPath}, {name=*, type=Node, filters=[{type=OpExpression, exprs=[{args=[{type=NodeSet, nodes=[{name=@class, type=Node}]}, {type=Literal, value='forceDetailPanel'}], type=FunctionCall, function=contains}, {args=[{type=NodeSet, nodes=[{name=@class, type=Node}]}, {type=Literal, value='detail-panel-root'}], type=FunctionCall, function=contains}], operator=or}]}, {type=DeepPath}, {name=*, type=Node, filters=[{type=OpExpression, exprs=[{type=UnaryOpExpression, operator=(, expr={type=NodeSet, nodes=[{name=records-record-layout-section, axis=self, type=Node}]}}, {type=UnaryOpExpression, operator=(, expr={type=OpExpression, exprs=[{type=UnaryOpExpression, operator=(, expr={type=OpExpression, exprs=[{type=OpExpression, exprs=[{type=NodeSet, nodes=[{name=section, axis=self, type=Node}]}, {type=NodeSet, nodes=[{name=div, axis=self, type=Node}]}], operator=or}, {type=NodeSet, nodes=[{name=fieldset, axis=self, type=Node}]}], operator=or}}, {args=[{type=NodeSet, nodes=[{name=@class, type=Node}]}, {type=Literal, value='forcePageBlockSection '}], type=FunctionCall, function=contains}], operator=and}}], operator=or}, {type=Literal, value=1}]}, {type=DeepPath}, {name=*, type=Node, filters=[{type=OpExpression, exprs=[{type=UnaryOpExpression, operator=(, expr={type=OpExpression, exprs=[{type=OpExpression, exprs=[{type=OpExpression, exprs=[{type=OpExpression, exprs=[{type=UnaryOpExpression, operator=(, expr={type=OpExpression, exprs=[{type=OpExpression, exprs=[{type=NodeSet, nodes=[{name=label, axis=self, type=Node}]}, {type=UnaryOpExpression, operator=(, expr={type=OpExpression, exprs=[{args=[{type=NodeSet, nodes=[{name=@class, type=Node}]}, {type=Literal, value='uiLabel'}], type=FunctionCall, function=contains}, {args=[{type=NodeSet, nodes=[{name=@class, type=Node}]}, {type=Literal, value='slds-form-element__label'}], type=FunctionCall, function=contains}], operator=or}}], operator=and}, {args=[{args=[{type=NodeSet, nodes=[{name=@class, type=Node}]}, {type=Literal, value='hide '}], type=FunctionCall, function=contains}], type=FunctionCall, function=not}], operator=and}}, {type=UnaryOpExpression, operator=(, expr={type=OpExpression, exprs=[{type=NodeSet, nodes=[{name=span, axis=self, type=Node}]}, {type=UnaryOpExpression, operator=(, expr={type=OpExpression, exprs=[{args=[{type=NodeSet, nodes=[{name=@class, type=Node}]}, {type=Literal, value='inputLabel'}], type=FunctionCall, function=contains}, {args=[{type=NodeSet, nodes=[{name=@class, type=Node}]}, {type=Literal, value='slds-form-element__label'}], type=FunctionCall, function=contains}], operator=or}}], operator=and}}], operator=or}, {type=UnaryOpExpression, operator=(, expr={type=OpExpression, exprs=[{type=NodeSet, nodes=[{name=div, axis=self, type=Node}]}, {args=[{type=NodeSet, nodes=[{name=@class, type=Node}]}, {type=Literal, value='test-id__field-label-container'}], type=FunctionCall, function=contains}], operator=and}}], operator=or}, {type=UnaryOpExpression, operator=(, expr={type=OpExpression, exprs=[{type=NodeSet, nodes=[{name=lightning-grouped-combobox, axis=self, type=Node}]}, {args=[{type=NodeSet, nodes=[{name=@class, type=Node}]}, {type=Literal, value='forceTextEnumLookup'}], type=FunctionCall, function=contains}], operator=and}}], operator=or}, {type=UnaryOpExpression, operator=(, expr={type=OpExpression, exprs=[{type=OpExpression, exprs=[{type=NodeSet, nodes=[{name=div, axis=self, type=Node}]}, {args=[{type=NodeSet, nodes=[{name=@class, type=Node}]}, {type=Literal, value='lightningInputRichText'}], type=FunctionCall, function=contains}], operator=and}, {type=NodeSet, nodes=[{name=lightning-input-rich-text, axis=self, type=Node}]}], operator=or}}], operator=or}}, {type=UnaryOpExpression, operator=(, expr={type=OpExpression, exprs=[{type=NodeSet, nodes=[{name=., type=Node}, {type=DeepPath}, {fn={type=FunctionCall, function=text}, type=Node, filters=[{type=OpExpression, exprs=[{type=FunctionCall, function=normalize-space}, {type=Literal, value='Account Name'}], operator==}]}]}, {type=OpExpression, exprs=[{type=NodeSet, nodes=[{name=., type=Node}, {type=DeepPath}, {fn={type=FunctionCall, function=text}, type=Node}]}, {type=Literal, value='Account Name'}], operator==}], operator=or}}], operator=and}]}, {type=ShallowPath}, {name=div, filters=[{type=Literal, value=1}], axis=ancestor, type=Node}]}]}]&amp;br/&gt;Capabilities {acceptInsecureCerts: false, browserName: chrome, browserVersion: 130.0.6723.117, chrome: {chromedriverVersion: 130.0.6723.70 (4d304ce63c47..., userDataDir: C:\Users\anubhav.sharma\git...}, fedcm:accounts: true, networkConnectionEnabled: false, pageLoadStrategy: normal, platformName: windows, proxy: Proxy(direct), setWindowRect: true, strictFileInteractability: false, timeouts: {implicit: 0, pageLoad: 300000, script: 30000}, unhandledPromptBehavior: dismiss and notify, webauthn:extension:credBlob: true, webauthn:extension:largeBlob: true, webauthn:extension:minPinLength: true, webauthn:extension:prf: true, webauthn:virtualAuthenticators: true}&amp;br/&gt;Session ID: e45746e46e8aba380b784ae57d63e0ca]</div><div class='TestOutput inf'>Processing Named Value.  Name: Phone, Value: PrimitiveValueImpl [ value: 6787645637, valueId=1d3, createdUpdateSeq=157, updatedUpdateSeq=157]</div><div class='TestOutput sev'>Error filling field.  Field: Phone, cause: [NoSuchWindowException: no such window: target window already closed&lt;br/&gt;from unknown error: web view not found&lt;br/&gt;  (Session info: chrome=130.0.6723.117)&lt;br/&gt;Build info: version: '4.16.1', revision: '9b4c83354e'&lt;br/&gt;System info: os.name: 'Windows 11', os.arch: 'amd64', os.version: '10.0', java.version: '11.0.24'&lt;br/&gt;Driver info: org.openqa.selenium.chrome.ChromeDriver$$EnhancerByCGLIB$$dace278c&lt;br/&gt;Command: [e45746e46e8aba380b784ae57d63e0ca, executeScript {script=return document.body, args=[]}]&lt;br/&gt;Capabilities {acceptInsecureCerts: false, browserName: chrome, browserVersion: 130.0.6723.117, chrome: {chromedriverVersion: 130.0.6723.70 (4d304ce63c47..., userDataDir: C:\Users\anubhav.sharma\git...}, fedcm:accounts: true, networkConnectionEnabled: false, pageLoadStrategy: normal, platformName: windows, proxy: Proxy(direct), setWindowRect: true, strictFileInteractability: false, timeouts: {implicit: 0, pageLoad: 300000, script: 30000}, unhandledPromptBehavior: dismiss and notify, webauthn:extension:credBlob: true, webauthn:extension:largeBlob: true, webauthn:extension:minPinLength: true, webauthn:extension:prf: true, webauthn:virtualAuthenticators: true}&lt;br/&gt;Session ID: e45746e46e8aba380b784ae57d63e0ca]</div><div class='TestOutput inf'>Going to update browser window handles.</div><div class='TestOutput sev'>[WebDriverException: disconnected: not connected to DevTools&lt;br/&gt;  (failed to check if window was closed: disconnected: not connected to DevTools)&lt;br/&gt;  (Session info: chrome=130.0.6723.117)&lt;br/&gt;Build info: version: '4.16.1', revision: '9b4c83354e'&lt;br/&gt;System info: os.name: 'Windows 11', os.arch: 'amd64', os.version: '10.0', java.version: '11.0.24'&lt;br/&gt;Driver info: org.openqa.selenium.chrome.ChromeDriver$$EnhancerByCGLIB$$dace278c&lt;br/&gt;Command: [e45746e46e8aba380b784ae57d63e0ca, getWindowHandles {}]&lt;br/&gt;Capabilities {acceptInsecureCerts: false, browserName: chrome, browserVersion: 130.0.6723.117, chrome: {chromedriverVersion: 130.0.6723.70 (4d304ce63c47..., userDataDir: C:\Users\anubhav.sharma\git...}, fedcm:accounts: true, networkConnectionEnabled: false, pageLoadStrategy: normal, platformName: windows, proxy: Proxy(direct), setWindowRect: true, strictFileInteractability: false, timeouts: {implicit: 0, pageLoad: 300000, script: 30000}, unhandledPromptBehavior: dismiss and notify, webauthn:extension:credBlob: true, webauthn:extension:largeBlob: true, webauthn:extension:minPinLength: true, webauthn:extension:prf: true, webauthn:virtualAuthenticators: true}&lt;br/&gt;Session ID: e45746e46e8aba380b784ae57d63e0ca]</div><div class='TestItemOutcome Failed'><div style='float: right; font-size: 0.8em;'><img src='../..//timer_16x16.gif' style='height: 16; padding-top: 2px;'/><span style='padding-bottom: 2px;'>13:55:57 (01:03.610)</span></div>Test Step failed.</div></div><div class='ApiCallImpl'><div class='TestItemTitle'><div style='float: right; font-size: 0.8em;'><img src='../..//timer_16x16.gif' style='height: 16; padding-top: 2px;'/><span style='padding-bottom: 2px;'>13:55:57 (01:03.614)</span></div>Start of Test Step Click the Save button</div><div class='TestOutput inf'>Start of Interact.  Connection: SalesforceConn, Locator: ui:locator?name=save&binding=sf%3Aui%3Abinding%3Aobject%3Fobject%3DAccount%26action%3Dsave, before wait: default, after wait: default, auto retry: ui:wait:autoRetry:timeout=10</div><div class='TestOutput sev'>[WebDriverException: disconnected: not connected to DevTools&lt;br/&gt;  (failed to check if window was closed: disconnected: not connected to DevTools)&lt;br/&gt;  (Session info: chrome=130.0.6723.117)&lt;br/&gt;Build info: version: '4.16.1', revision: '9b4c83354e'&lt;br/&gt;System info: os.name: 'Windows 11', os.arch: 'amd64', os.version: '10.0', java.version: '11.0.24'&lt;br/&gt;Driver info: org.openqa.selenium.chrome.ChromeDriver$$EnhancerByCGLIB$$dace278c&lt;br/&gt;Command: [e45746e46e8aba380b784ae57d63e0ca, getWindowHandles {}]&lt;br/&gt;Capabilities {acceptInsecureCerts: false, browserName: chrome, browserVersion: 130.0.6723.117, chrome: {chromedriverVersion: 130.0.6723.70 (4d304ce63c47..., userDataDir: C:\Users\anubhav.sharma\git...}, fedcm:accounts: true, networkConnectionEnabled: false, pageLoadStrategy: normal, platformName: windows, proxy: Proxy(direct), setWindowRect: true, strictFileInteractability: false, timeouts: {implicit: 0, pageLoad: 300000, script: 30000}, unhandledPromptBehavior: dismiss and notify, webauthn:extension:credBlob: true, webauthn:extension:largeBlob: true, webauthn:extension:minPinLength: true, webauthn:extension:prf: true, webauthn:virtualAuthenticators: true}&lt;br/&gt;Session ID: e45746e46e8aba380b784ae57d63e0ca]</div><div class='TestItemOutcome Failed'><div style='float: right; font-size: 0.8em;'><img src='../..//timer_16x16.gif' style='height: 16; padding-top: 2px;'/><span style='padding-bottom: 2px;'>13:55:57 (01:03.646)</span></div>Test Step failed.</div></div><div class='ApiCallImpl'><div class='TestItemTitle'><div style='float: right; font-size: 0.8em;'><img src='../..//timer_16x16.gif' style='height: 16; padding-top: 2px;'/><span style='padding-bottom: 2px;'>13:55:57 (01:03.652)</span></div>Start of Test Step Navigate: Refresh</div><div class='TestOutput inf'>Start of UI Navigate.  Connection: SalesforceConn</div><div class='TestOutput sev'>[WebDriverException: disconnected: not connected to DevTools&lt;br/&gt;  (failed to check if window was closed: disconnected: not connected to DevTools)&lt;br/&gt;  (Session info: chrome=130.0.6723.117)&lt;br/&gt;Build info: version: '4.16.1', revision: '9b4c83354e'&lt;br/&gt;System info: os.name: 'Windows 11', os.arch: 'amd64', os.version: '10.0', java.version: '11.0.24'&lt;br/&gt;Driver info: org.openqa.selenium.chrome.ChromeDriver$$EnhancerByCGLIB$$dace278c&lt;br/&gt;Command: [e45746e46e8aba380b784ae57d63e0ca, getWindowHandles {}]&lt;br/&gt;Capabilities {acceptInsecureCerts: false, browserName: chrome, browserVersion: 130.0.6723.117, chrome: {chromedriverVersion: 130.0.6723.70 (4d304ce63c47..., userDataDir: C:\Users\anubhav.sharma\git...}, fedcm:accounts: true, networkConnectionEnabled: false, pageLoadStrategy: normal, platformName: windows, proxy: Proxy(direct), setWindowRect: true, strictFileInteractability: false, timeouts: {implicit: 0, pageLoad: 300000, script: 30000}, unhandledPromptBehavior: dismiss and notify, webauthn:extension:credBlob: true, webauthn:extension:largeBlob: true, webauthn:extension:minPinLength: true, webauthn:extension:prf: true, webauthn:virtualAuthenticators: true}&lt;br/&gt;Session ID: e45746e46e8aba380b784ae57d63e0ca]</div><div class='TestItemOutcome Failed'><div style='float: right; font-size: 0.8em;'><img src='../..//timer_16x16.gif' style='height: 16; padding-top: 2px;'/><span style='padding-bottom: 2px;'>13:55:57 (01:03.696)</span></div>Test Step failed.</div></div><div class='TestOutput sev'>One or more Sub-Test Steps failed.</div><div class='TestOutput sev'>[WebDriverException: disconnected: not connected to DevTools&lt;br/&gt;  (failed to check if window was closed: disconnected: not connected to DevTools)&lt;br/&gt;  (Session info: chrome=130.0.6723.117)&lt;br/&gt;Build info: version: '4.16.1', revision: '9b4c83354e'&lt;br/&gt;System info: os.name: 'Windows 11', os.arch: 'amd64', os.version: '10.0', java.version: '11.0.24'&lt;br/&gt;Driver info: org.openqa.selenium.chrome.ChromeDriver$$EnhancerByCGLIB$$dace278c&lt;br/&gt;Command: [e45746e46e8aba380b784ae57d63e0ca, getWindowHandles {}]&lt;br/&gt;Capabilities {acceptInsecureCerts: false, browserName: chrome, browserVersion: 130.0.6723.117, chrome: {chromedriverVersion: 130.0.6723.70 (4d304ce63c47..., userDataDir: C:\Users\anubhav.sharma\git...}, fedcm:accounts: true, networkConnectionEnabled: false, pageLoadStrategy: normal, platformName: windows, proxy: Proxy(direct), setWindowRect: true, strictFileInteractability: false, timeouts: {implicit: 0, pageLoad: 300000, script: 30000}, unhandledPromptBehavior: dismiss and notify, webauthn:extension:credBlob: true, webauthn:extension:largeBlob: true, webauthn:extension:minPinLength: true, webauthn:extension:prf: true, webauthn:virtualAuthenticators: true}&lt;br/&gt;Session ID: e45746e46e8aba380b784ae57d63e0ca]</div><div class='TestItemOutcome Failed'><div style='float: right; font-size: 0.8em;'><img src='../..//timer_16x16.gif' style='height: 16; padding-top: 2px;'/><span style='padding-bottom: 2px;'>13:55:57 (01:03.717)</span></div>Test Step failed.</div></div><div class='TestItemOutcome Failed'><div style='float: right; font-size: 0.8em;'><img src='../..//timer_16x16.gif' style='height: 16; padding-top: 2px;'/><span style='padding-bottom: 2px;'>13:55:57 (01:03.721)</span></div>TestClauseImpl failed.</div></div><div class='TestOutput inf'>Start of iteration 3 of 3.</div><div class='TestClauseImpl'><div class='TestItemTitle'><div style='float: right; font-size: 0.8em;'><img src='../..//timer_16x16.gif' style='height: 16; padding-top: 2px;'/><span style='padding-bottom: 2px;'>13:55:57 (01:03.725)</span></div>Start of TestClauseImpl Iteration 3</div><div class='ApiCallImpl'><div class='TestItemTitle'><div style='float: right; font-size: 0.8em;'><img src='../..//timer_16x16.gif' style='height: 16; padding-top: 2px;'/><span style='padding-bottom: 2px;'>13:55:57 (01:03.725)</span></div>Start of Test Step On SF Account New screen</div><div class='TestOutput inf'>Start of With Screen.  Connection Name: SalesforceConn, target: sf:ui:target?object=Account&action=New</div><div class='TestOutput sev'>[WebDriverException: disconnected: not connected to DevTools&lt;br/&gt;  (failed to check if window was closed: disconnected: not connected to DevTools)&lt;br/&gt;  (Session info: chrome=130.0.6723.117)&lt;br/&gt;Build info: version: '4.16.1', revision: '9b4c83354e'&lt;br/&gt;System info: os.name: 'Windows 11', os.arch: 'amd64', os.version: '10.0', java.version: '11.0.24'&lt;br/&gt;Driver info: org.openqa.selenium.chrome.ChromeDriver$$EnhancerByCGLIB$$dace278c&lt;br/&gt;Command: [e45746e46e8aba380b784ae57d63e0ca, getWindowHandles {}]&lt;br/&gt;Capabilities {acceptInsecureCerts: false, browserName: chrome, browserVersion: 130.0.6723.117, chrome: {chromedriverVersion: 130.0.6723.70 (4d304ce63c47..., userDataDir: C:\Users\anubhav.sharma\git...}, fedcm:accounts: true, networkConnectionEnabled: false, pageLoadStrategy: normal, platformName: windows, proxy: Proxy(direct), setWindowRect: true, strictFileInteractability: false, timeouts: {implicit: 0, pageLoad: 300000, script: 30000}, unhandledPromptBehavior: dismiss and notify, webauthn:extension:credBlob: true, webauthn:extension:largeBlob: true, webauthn:extension:minPinLength: true, webauthn:extension:prf: true, webauthn:virtualAuthenticators: true}&lt;br/&gt;Session ID: e45746e46e8aba380b784ae57d63e0ca]</div><div class='TestOutput sev'>The required connection name isn't present.  This should come from the containing With Screen API.</div><div class='TestItemOutcome Failed'><div style='float: right; font-size: 0.8em;'><img src='../..//timer_16x16.gif' style='height: 16; padding-top: 2px;'/><span style='padding-bottom: 2px;'>13:55:58 (01:03.766)</span></div>Test Step failed.</div></div><div class='TestItemOutcome Failed'><div style='float: right; font-size: 0.8em;'><img src='../..//timer_16x16.gif' style='height: 16; padding-top: 2px;'/><span style='padding-bottom: 2px;'>13:55:58 (01:03.766)</span></div>TestClauseImpl failed.</div></div><div class='TestOutput inf'>Reached the end of the List.</div><div class='TestItemOutcome Failed'><div style='float: right; font-size: 0.8em;'><img src='../..//timer_16x16.gif' style='height: 16; padding-top: 2px;'/><span style='padding-bottom: 2px;'>13:55:58 (01:03.770)</span></div>Test Step failed.</div></div><div class='TestItemOutcome Failed'><div style='float: right; font-size: 0.8em;'><img src='../..//timer_16x16.gif' style='height: 16; padding-top: 2px;'/><span style='padding-bottom: 2px;'>13:55:58 (01:03.772)</span></div>Test Case failed.</div></div><div class='TestOutput inf'>Handling managed resource.  Name: SalesforceConn</div><div class='TestOutput war'>Failed to perform ui logout, before closing the connection.</div><div class='TestOutput sev'>Object delete failed. Id: 001J200000B7rtgIAB, Message: You cannot delete an active account</div><div class='TestOutput sev'>Error when attempting to close Salesforce Connection.  Name: SalesforceConn</div>
	</div></body>
</html>
